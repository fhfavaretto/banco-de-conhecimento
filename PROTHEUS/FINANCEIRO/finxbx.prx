#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "finxbx.ch"
#INCLUDE "FILEIO.CH"
 
/* FINXATU.PRX */ 
Static lF070CM
Static lUltiLote                                                                                                                                                                                                                                                   
Static cTipoCM

/* MATXFUNB.PRX */
Static __lGEMJUROS
Static __lE1_NCONTR
Static __lNewJuros
Static __lFJURCST
Static __lFJURREC
Static dLastPcc		:= CTOD("22/06/2015")

STATIC nLenPref		:= 0
STATIC nLenNume		:= 0 
STATIC nLenParc		:= 0
STATIC nLenTipo		:= 0
STATIC nLenClie		:= 0
STATIC nLenLoja		:= 0
STATIC nLenNatu		:= 0
STATIC _lIniVar		:= .F.
//PCREQ-3768-Contas a Pagar_Valores Acessorios_CP
Static cNatIRF		:= NIL
Static nTamNat		:= NIL
//Inscrição de Cobrança.
STATIC __nMsgIns	:= 1 // 1 - Em lote, 2 - Em Lote confirmada, 3 - Em lote cancelado.

//Verificação de existência dos pontos de entrada
STATIC lFA070ADTSE5 := NIL

STATIC lf70GrSe1 	:= NIL
STATIC lF200GERA	:= NIL
STATIC lF070GerAb	:= NIL
STATIC lFinSalTit	:= NIL
STATIC lF070GrvHis	:= NIL
STATIC lFin70BxIr	:= NIL
STATIC lF070Imp2	:= NIL
STATIC lFa070Imp	:= NIL
STATIC lF070HIST	:= NIL
STATIC lFINAJURO	:= NIL
STATIC lF070DISS	:= NIL
STATIC lSE3FI070	:= NIL
STATIC lSE3F070		:= NIL
STATIC lF070MV1		:= NIL
STATIC lF70E5ADT	:= NIL
STATIC lSE5FI070	:= NIL
STATIC lF070VMOT	:= NIL
STATIC lFA070CMI	:= NIL
//Deixar sempre esta por ultimo
STATIC lF070IRAB	:= FxIniStat()

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FINXBX

Funções  genéricas relacionadas as baixas CR e CP.

@Author Vários
@version 12
@since   08/12/2014

/*/
//-----------------------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------------------
// Funcoes retiradas do arquivo FINXATU.PRX
//-----------------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FADIGICHQ

Funcao que abre ou não o get do número de cheque na baixa CP (FINA080).
Arquivo anterior: FINXATU.PRX

@Author	Mauricio Pequim Jr.
@since	15/10/1997
/*/
//-----------------------------------------------------------------------------------------------------
Function faDigiChq()
Local lRet := .T.

// Nao habilita o numero de cheque para :
// - Adiantamento, Banco Caixa, Carteira ou Motivo igual a D‚bito em C/C
If (SE2->E2_TIPO $ MVPAGANT+"/"+MV_CPNEG) .or. ;
	cBanco $ Left(SuperGetMv("MV_CXFIN",,""),TamSX3("A6_COD")[1])       .or. ;
	cBanco $ SuperGetMv("MV_CARTEIR",,"")     .or. ;
	TrazCodMot(cMotBx) $ "DEB/DAC"   .or. ;
	! ChqMotBx(cMotBx)				   .or. ;
	(SuperGetMv("MV_CHQBOR",,"") == "N" .and. !Empty(SE2->E2_NUMBOR))
	lRet := .F.
Endif
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070CORR

Calculo de Correção monetária na baixa.
Arquivo anterior: FINXATU.PRX

@Author	Pilar S. Albaladejo
@since	30/01/1996
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa070Corr(nEstOriginal,nTxMoeda)
Local nValor1		:= 0
Local nBaseCorrecao := 0

Default cTipoCM	:= SuperGetMV("MV_TIPOCM",,"O")
DEFAULT nTxMoeda	:= 0

nEstOriginal := Iif(nEstOriginal==Nil,nValEstrang,nEstOriginal)

If cTipoCM == "O"		// Pelo Original (O)
	nBaseCorrecao := nEstOriginal
Else
	nBaseCorrecao := nValEstrang				// Pelo Total (T)
EndIf
If cPaisLoc<>"BRA"
	nCentMd1:=4
	nTxMoeda:=aTxMoedas[SE1->E1_MOEDA][2]
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Calcula o valor na moeda escolhida na data da ultima variacao   ³
//³ ou na data de emissao (caso nao tenha sofrido ainda nenhuma	  ³
//³ variacao.																		  ³
//³ Calcula o valor na moeda escolhida para a database.				  ³
//³ Subtrai um valor do outro para apurar a variacao. 				  ³
//³ A Correcao pode ser parametrizada para ser calculada pelo Origi-³
//³ nal ou pelo Total (Parametro MV_TIPOCM)           				  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If STR(nBaseCorrecao,17,2) == STR(SE1->E1_VALOR,17,2) .AND. Empty(SE1->E1_DTVARIA)
	nValor1 := SE1->E1_VLCRUZ
Else
	If !Empty(SE1->E1_TXMDCOR)
    	nValor1 := xMoeda(nBaseCorrecao,SE1->E1_MOEDA,1,Iif(Empty(SE1->E1_DTVARIA),SE1->E1_EMISSAO,SE1->E1_DTVARIA),8,SE1->E1_TXMDCOR)
    Else
		nValor1 := xMoeda(nBaseCorrecao,SE1->E1_MOEDA,1,Iif(Empty(SE1->E1_DTVARIA),SE1->E1_EMISSAO,SE1->E1_DTVARIA),8,Iif(Empty(SE1->E1_DTVARIA),SE1->E1_TXMOEDA,0))
	EndIf
Endif
If ( cPaisLoc<>"BRA" )
	nValor1:= xMoeda(nBaseCorrecao,SE1->E1_MOEDA,1,Iif(Empty(SE1->E1_DTVARIA),SE1->E1_EMISSAO,SE1->E1_DTVARIA),8,Iif(Empty(SE1->E1_DTVARIA),SE1->E1_TXMOEDA,0))
	If Type("aTxMoedas")#"U" .AND. !( aTxMoedas == Nil )
 		nTxMoeda := aTxMoedas[SE1->E1_MOEDA][2]
 	Endif
Endif

If TrazCodMot(cMotBx) == "DEV"
	nValorM := xMoeda(nBaseCorrecao,SE1->E1_MOEDA,1,SE1->E1_EMISSAO,8,If(SE1->E1_TXMOEDA > 0 .And. SE1->E1_TXMOEDA == nTxMoeda,SE1->E1_TXMOEDA,nTxMoeda))
ELSE
	nValorM := xMoeda(nBaseCorrecao,SE1->E1_MOEDA,1,dBaixa,8,If(SE1->E1_TXMOEDA > 0 .And. SE1->E1_TXMOEDA == nTxMoeda,SE1->E1_TXMOEDA,nTxMoeda))
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica atraves do parametro MV_CALCCM se sera calculada a cor-³
//³ recao monetaria.                                           	  ³
//³ Caso o parametro nao exista, sera assumido "S"						  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If ((Type("nMoedaBco")<>"U" .And. SE1->E1_MOEDA > 1 .And. SE1->E1_MOEDA <> nMoedaBco) .OR. ;
 	(Type("nMoedaBco")=="U" .AND. SE1->E1_MOEDA > 1 .AND. FUNNAME() $ "FINA330#FINA450#FINA740" )) .AND. ;
	IIf(cPaisLoc=="BRA", SuperGetMv("MV_CALCCM",,"S") == "S" ,.T. )

	If lF070CM
		nCm := Execblock("F070CM",.F.,.F.,{nTxMoeda})
	Else
		nCM := nValorM - nValor1
	Endif
Else
	nCM := 0
Endif
Return .T.

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SOMACHEQCR

Soma o valor dos cheques recebidos relacionados a um determinado titulo.
Arquivo anterior: FINXATU.PRX

@Author	Claudio D. de Souza
@since	06/11/2003
/*/
//-----------------------------------------------------------------------------------------------------
Function SomaCheqCr(lEstaNaBase,cPrefixo,cNum,cParcela,cTipo,cCliente,lConsUsBx,cSequencia)
Local aArea 	:= GetArea()
Local aAreaSef	:= SEF->(GetArea())
Local nRet		:= 0
Local nX		:= 0 

#IFDEF TOP
	Local cQuery
#ENDIF

DEFAULT lConsUsBx := .T.      
DEFAULT cSequencia :=""

// Se nao estiver na base ainda, soma o aCols, onde estao os cheques que serao
// cadastrados
If !lEstaNaBase .And. (Type("aCols") == "A" .And. !Empty(aCols))
	For nX := 1 To Len(aCols)
		// Se o cheque nao estiver deletado, os dados forem validos
		If !aCols[nX][Len(aCols[1])]	.And.;
			!Empty(aCols[nX][1])		.And.;
			!Empty(aCols[nX][2])		.And.;
			!Empty(aCols[nX][3])		.And.;
			!Empty(aCols[nX][4])		.And.;
			!Empty(aCols[nX][5])		.And.;
			!Empty(aCols[nX][6])		.And.;
			!Empty(aCols[nX][7])		.And.;
			!Empty(aCols[nX][8])		.And.;
			!Empty(aCols[nX][9])	
			
			// Se o identificador de que o cheque ja foi utilizado na baixa estiver como nao, devido as
			// baixas parciais, pois nas baixas futuras esses cheques nao podem mais serem utilizados
			// na geracao do movimento bancario, soma o valor do cheque
			If aCols[nX][15] != "Sim" .And. IIf(!Empty(cSequencia),cSequencia == aCols[nX][14],.T.)			
		  		nRet += aCols[nX][6]
		  	Endif	
	  		
		Endif
	Next
Else
	#IFDEF TOP
		cQuery := "SELECT Sum(EF_VALORBX) Soma FROM "+RetSqlName("SEF")+" WHERE "	   
		cQuery += "EF_FILIAL='"+xFilial("SEF")+"' AND "
		cQuery += "EF_PREFIXO='"+cPrefixo+"' AND "
		cQuery += "EF_TITULO='"+cNum+"' AND "
		cQuery += "EF_PARCELA='"+cParcela+"' AND "
		cQuery += "EF_TIPO='"+cTipo+"' AND "
		cQuery += "(EF_FORNECE='"+cCliente+"' OR "
		cQuery += " EF_CLIENTE='"+cCliente+"') AND "
		cQuery += "EF_NUM<>' ' AND "
		If lConsUsBx
			cQuery += "EF_USADOBX <>'S' AND "
		Endif     
		If !Empty(cSequencia)
			cQuery += "EF_SEQUENC='"+cSequencia+"' AND "	
		Endif     		
		cQuery += "D_E_L_E_T_<>'*'"
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"__SOMACHEQ",.T.,.T.)
		nRet := __SOMACHEQ->SOMA
		dbCloseArea()
	#ELSE
		dbSelectArea("SEF")
		SEF->(dbSetOrder(3))      
		SEF->(MsSeek(xFilial("SEF")+cPrefixo+cNum+cParcela+cTipo))
		While SEF->(!Eof()) .And.;
				SEF->(EF_FILIAL+EF_PREFIXO+EF_TITULO+EF_PARCELA+EF_TIPO) ==;
				xFilial("SEF")+cPrefixo+cNum+cParcela+cTipo
			If (SEF->EF_FORNECE == cCliente .Or.;
				SEF->EF_CLIENTE == cCliente) .And. !Empty(SEF->EF_NUM)
				If lConsUsBx .Or. SEF->EF_USADOBX != "S"
					nRet += SEF->EF_VALORBX // Proporcionaliza o valor ref. a baixa, devido as baixas parciais
				EndIf
			Endif	
			SEF->(dbSkip())
		EndDo
	#ENDIF
Endif	
RestArea(aAreaSEF)
RestArea(aArea)
Return nRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070PAD

Verifica qual lançamento padrão será utilizado na Baixa CR dependendo da situação de cobrança do titulo.
Arquivo anterior: FINXATU.PRX

@Author	Wagner Xavier
@since	26/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fA070Pad()
Local cPadrao:="520"

If AllTrim(SE1->E1_SITUACA) $ "0|F|G" .Or. Empty(SE1->E1_SITUACA)     //Carteira
	cPadrao := "520"
ElseIf AllTrim(SE1->E1_SITUACA) $ "1|H"     //Simples
	cPadrao := "521"
ElseIf AllTrim(SE1->E1_SITUACA) = "2"     //Descontada
	cPadrao := "522"
ElseIf AllTrim(SE1->E1_SITUACA) = "3"     //Caucionada
	cPadrao := "523"
ElseIf AllTrim(SE1->E1_SITUACA) = "4"     //Vinculada
	cPadrao := "524"
ElseIf AllTrim(SE1->E1_SITUACA) = "5"     //Advogado
	cPadrao := "525"
ElseIf AllTrim(SE1->E1_SITUACA) = "6"     //Judicial
	cPadrao := "526"
ElseIf AllTrim(SE1->E1_SITUACA) = "7"     //Caucao Descontada
	cPadrao := "528"
//Novas situacoes de cobranca do usuario
ElseIf FN022SITCB(SE1->E1_SITUACA)[1]		//Carteira cSituacao $ "0|F|G"
	cPadrao:="520"
ElseIf FN022SITCB(SE1->E1_SITUACA)[5]	//Simples e Cartorio   cSituacao $ "1|H"
	cPadrao:="521"
ElseIf FN022SITCB(SE1->E1_SITUACA)[3]	//Descontada 	cSituacao $ "2|7"
	cPadrao:="522"
ElseIf FN022SITCB(SE1->E1_SITUACA)[4]	//Cobranca em banco com protesto
	cPadrao:="526"
ElseIf FN022SITCB(SE1->E1_SITUACA)[2]	//Cobranca em banco sem protesto exceto Simples e Cartorio
	cPadrao:="524"
EndIf
Return cPadrao

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070GRV

Gravação da baixa de contas a receber.
Arquivo anterior: FINXATU.PRX

@Author	Wagner Xavier
@since	26/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fA070Grv(lPadrao,lDesconto,lContabiliza,cNsNum,lExterno,dDtCredito,;
						lJuros,cArqEnt,cOcorr,nTxMoeda,lGerChqAdt,aSeqSe5,aHdlPrv,lBloqSa1,lMultNat,oModelBxC)
Local nSalvRec		:= 0
Local cNum			:= ""
Local cPrefixo		:= ""
Local cParcela		:= ""
Local lAdiantamento	:= .f.
Local aBaixas		:= {}
Local nToler		:= 0
Local nSE1Rec 		:= 0
Local nValClient  	:= 0
Local nAtraso		:= 0
Local nVlEstOri		:= 0
Local xF200GERA
Local aCamposSE1 	:= {}
Local nSomaCheq 	:= 0
Local nX 			:= 0
Local nSaldoAtu 	:= 0
Local lBxParc 		:= .F.
Local nValRa 		:= 0
Local lLj440Proc 	:= .F. // Se processa rotina do SIGALOJA
Local nTamSeq		:= TamSX3("E5_SEQ")[1]
Local cSequencia 	:= Replicate("0",nTamSeq)
Local lVendedor		:= !Empty(SE1->E1_VEND1) .Or. ;
						!Empty(SE1->E1_VEND2) .Or. ;
						!Empty(SE1->E1_VEND3) .Or. ;
						!Empty(SE1->E1_VEND4) .Or. ;
						!Empty(SE1->E1_VEND5) .Or. ;
						AllTrim(SE1->E1_ORIGEM) $ "FINA280|FINA460"

//Controla o Pis Cofins e Csll na baixa (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default))
Local lPccBxCr		:= FPccBxCr()
Local nPisBaseA		:= 0
Local nCofBaseA		:= 0
Local nCslBaseA		:= 0

//Controla IRPJ na baixa
Local lIrPjBxCr		:= FIrPjBxCr()
Local nIrfBaseA		:= 0
Local nTamHist 		:= TamSX3("E1_HIST")[1] // Tamanho do campo HISTORICO

//Controla o tipo original do titulo originador
Local cTipoOr		:= ""
Local lAtuSldNat	:= .T.
Local nOpcx 		:= 0
Local nValRealiz 	:= 0

//Controle de abatimento
Local lTitpaiSE1 	:= .T.
Local bWhile 		:= {|| !EOF() .And. E1_FILIAL==xFilial("SE1") .And. E1_CLIENTE = cCliente	.And. E1_LOJA = cLoja .And. E1_PREFIXO=cPrefixo .And. E1_NUM == cNum .And. E1_PARCELA==cParcela }
Local nOrdTitPai	:= 0
Local lRaRtImp  	:= FRaRtImp()
Local lBQ10925		:= SuperGetMV("MV_BQ10925",,"2") == "1" .And. !lRaRtImp
Local lBruto		:= SuperGetMV("MV_BQ10925",,"2") == "1"
Local c070Hist		:= ""
Local aTitulos		:= {}

//.T. - Gera o titulo de ISS (se houver) na filial de destino juntamente com o titulo NF, baixando o titulo ISS na origem
//.F. - Nã gera o titulo de ISS na filial de destino, permanecendo o titulo ISS na origem em aberto. 
Local lTrfISSf		:= GetNewPar("MV_TRFISSF",.T.)
Local cFilOrgTr 	:= ""//Filial de origem do documento de ISS, processo de transferência
Local nForIss   	:= 1//Auxiliar para o For de busca do ISS, processo de transferência
Local nValImp 		:= 0
Local nPosBx		:= 0
Local aMotBx		:= ReadMotBx()
Local lImpBxCr		:= GetNewPar( "MV_IMPBXCR", "1" ) == "2" 
Local lJurMulDes	:= (SuperGetMv("MV_IMPBAIX",.t.,"2") == "1")
Local nTotJur		:= 0
Local nValForeing	:= 0 
Local lFini055		:= IsInCallStack("FINI055")
Local lRet			:= .T.
Local cParcRA		:= SuperGetMv("MV_1DUP",,"")
Local lIntRm    	:= .F.
Local cPrefRM 	:= SuperGetMv("MV_PREFRM",,"TIN") 
Local lIntegTIN	:= FindFunction( "GETROTINTEG" ) .and. FindFunction("FwHasEAI")

Private lRetParc	:= .T.
Private nValToler	:= 0

Default oModelBxC	:= NIL
Default lMultNat := .F.

If Type("cFilAbat") == "U"
	Private cFilAbat := cFilAnt
EndIf
If Type("nTotAbImp") == "U"
	Private nTotAbImp := 0
EndIf

If Type("lVlrMaior") == "U"
	Private lVlrMaior := .F.
EndIf

If Type("nVlrMaior") == "U"
	Private nVlrMaior := 0
EndIf
//Controle Numero Borderô - FINA200
If FunName() $ "FINA200" .Or. ( FunName() $ "FINA740" .And. FwIsInCallStack("FINA200") )
	Private cNumBor 	:= SE1->E1_NUMBOR
	If ! (lFini055 .or. AllTrim(SE1->E1_ORIGEM)=="FINI055") // Nao atualiza se for do TIN
		If !(FA070Integ(.F.))
			Return .F.
		Endif
	Endif	
EndIf

//Integração baixa via cnab
If ( FWHasEAI("FINA070",.T.,,.T.) ) .And. ( lIntegTIN .and. AllTrim(SE1->E1_ORIGEM)=="FINI055" ) .Or.;
	( FWHasEAI("FINI070A",.T.,,.T.) .And. ( AllTrim(SE1->E1_ORIGEM) $ 'L|S|T' .Or. SE1->E1_IDLAN > 0 ) )
	lIntRm := .T. 
Endif

// Zerar variaveis para contabilizar os impostos da lei 10925.
VALOR5 := 0
VALOR6 := 0
VALOR7 := 0

DEFAULT nTxMoeda := 0
DEFAULT lGerChqAdt := .F. // Gera cheque para Adiant ? Pergunta na baixa manual.
Default lBloqSa1 := .T.

If Funname() == "FINA070"
	DEFAULT nMoedaBco := 1
Else
	If cPaisLoc == "ARG"
		If Funname() != "FINA846" .And. Funname() != "FINA074"
			nMoedaBco := 1
		EndIf
	Else
		nMoedaBco := 1
	EndIf
Endif

lDesconto	:= Iif(lDesconto=Nil,Iif(mv_par03==1,.T.,.F.),lDesconto)
lContabiliza:= Iif(lContabiliza=Nil,Iif(mv_par04==1,.T.,.F.),lContabiliza)
lJuros		:= Iif(lJuros == NIL, .F., lJuros )
cNsNum		:= Iif(cNsNum==NIL," ",cNsNum)
cArqEnt     := Iif(cArqEnt==Nil," ",cArqEnt)		// Oriundo do Fina200 (Arquivo Cnab)
nOtrGa      := If(Type("nOtrGa") != "N",0,nOtrGa)
nDifCambio  := IF (Type("nDifCambio") != "N",0,nDifCambio)
nAcresc     := If(Type("nAcresc") != "N",0,nAcresc)
nAcrescf    := If(Type("nAcrescf") != "N",nAcresc,nAcrescf)
nDecresc    := If(Type("nDecresc") != "N",0,nDecresc)
nPis		:= If(Type("nPis") != "N",0,nPis)
nCofins	    := If(Type("nCofins") != "N",0,nCofins)
nCsll	   	:= If(Type("nCsll") != "N",0,nCsll)
nIrrf	   	:= If(Type("nIrrf") != "N",0,nIrrf)
cOcorr      := Iif(cOcorr==Nil,"  ",cOcorr)
cModSpb		:= If (Type("cModSpb") != "C","1",cModSpb)
nOldIrrf 	:= If(Type("nOldIrrf") != "N",0,nOldIrrf)
nPisBaseR	:= Iif(Type("nPisBaseR") != "N",0,nPisBaseR)
nCofBaseR	:= Iif(Type("nCofBaseR") != "N",0,nCofBaseR)
nCslBaseR	:= Iif(Type("nCslBaseR") != "N",0,nCslBaseR)
nIrfBaseR	:= Iif(Type("nIrfBaseR") != "N",0,nIrfBaseR)
nVA			:= If(Type("nVA") != "N", 0, nVA)

If Funname() =="FINA630".and. SE1->E1_TIPO $ MVRECANT
		cPortado    := SE1->E1_PORTADO
		cBanco      := SE1->E1_PORTADO
		cAgencia    := SE1->E1_AGEDEP
		cConta      := SE1->E1_CONTA
		lGerChqAdt		:= .F.
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Este parƒmetro informa se a fun‡„o foi chamada pelo pr¢prio Fina070	³
//³ou por outro programa externo, tal como o Fina200							³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ValType( lExterno ) # "L"
	lExterno := .F.
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza a baixa do titulo											  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lExterno
	nValPadrao := nValRec-(nJuros + nVA +Iif(SE1->E1_MOEDA<=1,nCm,0)+nMulta-nDescont-nTotAbat+nAcresc-nDecresc-If(lPccBxCr,nPis+nCofins+nCsll,0)-Iif(lIrPjBxCr,nIrrf,0))
	nValPadrao := Round(NoRound(xMoeda(nValPadrao,1,SE1->E1_MOEDA,dBaixa,3,,SE1->E1_TXMOEDA),3),2)
	If nValPadrao < SE1->E1_SALDO
		nValpadrao -= nTotAbat
	Endif
Else
	If lRaRtImp  
		If lJurMulDes .and. nValRec < nAcresc 
			nValPadrao := nValRec
		Else
			nValPadrao := nValRec-(nJuros + nVA +Iif(SE1->E1_MOEDA<=1,nCm,0)+nMulta-nDescont-nOtrga-nTotAbat+nAcresc-nDecresc-If(lPccBxCr,nPis+nCofins+nCsll,0)-Iif(lIrPjBxCr,nIrrf,0))
		EndIf
		If nValPadrao < SE1->E1_SALDO
			nValpadrao -= nTotAbat
		Endif
	Else
		nValPadrao := nValRec-(nJuros + nVA +Iif(SE1->E1_MOEDA<=1,nCm,0)+nMulta-nDescont-nOtrga+nAcresc-nDecresc-If(lPccBxCr,nPis+nCofins+nCsll,0)-Iif(lIrPjBxCr,nIrrf,0))
	EndIf
Endif

If !lIrPjBxCr .and. lImpBxCr .and. lF070Imp2 .and. lFa070Imp .and. nOldIrrf == 0 .and. nIrrf > 0
	nValPadrao	:= nValPadrao + nIrrf
EndIf

If lFinSalTit
	nValPadrao += ExecBlock("FinSalTit")
Endif

nSalTit := Round(NoRound(xMoeda(SE1->E1_SALDO,SE1->E1_MOEDA,nMoedaBco,dBaixa,3,nTxMoeda),3),2) //Converte o saldo do titulo a moeda 1.

If !lIntRm .and. SE1->E1_PREFIXO <> cPrefRM
	If nSalTit == 0 .or. (lExterno .and. nSalTit > 0 .and. ( nSalTit < nValPadrao .Or. lVlrMaior) )
		//Caso o Cliente pague o titulo mais de uma vez e o titulo ja se encontrava 
		//baixado, gero um RA para informar o credito a maior em minha conta bancaria
		//e ao mesmo tempo disponibilizo o credito ao clientepara posterior devolucao ou
		//compensacao. Este processo somente sera "startado" se for num retorno 
		//CNAB (lExterno = .T.) e se for parametrizado para tal (MV_REC2TIT = "1")
		If SuperGetMv("MV_REC2TIT",,"2") == "1" .and. lExterno
			//Gero RA no SE1 e seu movimento no SE5
			nSaldoAtu := nSalTit
			nValRa	 := IIF(lVlrMaior, nVlrMaior, nValRec)
			lBxParc	 := lVlrMaior
			//Verifico se o titulo sofreu apenas uma baixa parcial antes da recepcao do CNAB
			//Neste caso o valor da devolucao sera o valor do principal pago a maior
	        If nSalTit > 0 .and. nSalTit < nValPadrao
				nValRec		:= nSaldoAtu+(nJuros + nVA +Iif(SE1->E1_MOEDA<=1,nCm,0)+nMulta-nDescont-nTotAbat+nAcresc-nDecresc)
				nValRa		:= nValPadrao - nSalTit
				nValPadrao	:= nValRec-(nJuros + nVA +Iif(SE1->E1_MOEDA<=1,nCm,0)+nMulta-nDescont-nTotAbat+nAcresc-nDecresc)
				lBxParc		:= .T.
			Endif
			DbSelectArea("SE1")
			If lPccBxCr
				nPisBaseA := nPisBaseR
				nCofBaseA := nCofBaseR
				nCslBaseA := nCslBaseR
			EndIf
			
			If lIrPjBxCr
				nIrfBaseA := nIrfBaseR
			EndIf
			For nX := 1 To fCount()
				IF Alltrim(FieldName(nX)) $ "E1_PREFIXO#E1_NUM#E1_NATUREZ#E1_CLIENTE#E1_LOJA#E1_NOMCLI#E1_FILORIG#E1_NUMRA"
					Aadd(aCamposSE1, {FieldName(nX), FieldGet(nX)})
				Endif
			Next nX
		    nRecNow := SE1->(RECNO())
			nOrdNow := SE1->(IndexOrd())
			
			//Verifico se a parcela já existe na tabela SE1
			SE1->(dbSetOrder(1))
			While SE1->(dbSeek(xFilial("SE1")+SE1->(E1_PREFIXO+E1_NUM)+cParcRA+Substr(MVRECANT,1,3)))
				cParcRa := Soma1(cParcRa)
			Enddo
	
			// Descarrega aCamposSE1 no SE1 para que todos os campos preenchidos no titulo principal
			// sejam replicados para o RA
			For nX := 1 To Len(aCamposSE1)
				If !Empty(aCamposSE1[nX][2])
					aAdd(aTitulos,{aCamposSE1[nX,01], aCamposSE1[nX,02], Nil})
				Endif
			Next
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Ponto de Entrada para tratamento de Historico no titulo de RA³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lF070HIST
				c070Hist := PadR(ExecBlock("F070HIST",.F.,.F.,{SE1->(E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO),nRecNow}),nTamHist)
			Else
				c070Hist := STR0001 //"Adiant.Bx.Duplicada-CNAB"
			Endif
	
			//Montagem do Array para ExecAuto
			aAdd(aTitulos,{"E1_PARCELA"	, cParcRa				, Nil })
			aAdd(aTitulos,{"E1_TIPO"	, Substr(MVRECANT,1,3)	, Nil })
			aAdd(aTitulos,{"E1_PORTADO"	, cBanco				, Nil })
			aAdd(aTitulos,{"E1_AGEDEP"	, cAgencia				, Nil })
			aAdd(aTitulos,{"E1_CONTA"	, cConta				, Nil })
			aAdd(aTitulos,{"E1_EMISSAO"	, dDataBase				, Nil })
			aAdd(aTitulos,{"E1_EMIS1"	, dDataBase				, Nil })
			aAdd(aTitulos,{"E1_VENCTO"	, dDataBase				, Nil })
			aAdd(aTitulos,{"E1_VENCREA"	, dDataBase				, Nil })
			aAdd(aTitulos,{"E1_VALOR"	, nValRa				, Nil })
			aAdd(aTitulos,{"E1_VLCRUZ"	, nValRa				, Nil })
			aAdd(aTitulos,{"E1_SALDO"	, nValRa				, Nil })
			aAdd(aTitulos,{"E1_MOEDA"	, 1						, Nil })
			aAdd(aTitulos,{"E1_SITUACA" , "0"					, Nil })
			aAdd(aTitulos,{"E1_STATUS"	, "A"					, Nil })
			aAdd(aTitulos,{"E1_ORIGEM"	, "FINA040"				, Nil })
			aAdd(aTitulos,{"E1_FLUXO"	, "S"					, Nil })
			aAdd(aTitulos,{"E1_MULTNAT" , "2"					, Nil })
			aAdd(aTitulos,{"E1_PROJPMS" , "2"					, Nil })
			aAdd(aTitulos,{"E1_HIST"	, c070Hist				, Nil })
			If SpbInUse()
				aAdd(aTitulos,{"E1_MODSPB"	, "1"				, Nil })
			Endif		
	
			If lF200GERA
				xF200GERA := ExecBlock("F200GERA",.F.,.F.,{nRecNow,aTitulos})
				If ValType(xF200GERA) == "A"
					aTitulos := aClone(xF200GERA)
				EndIf
			EndIf
	
			lMsErroAuto := .F.					
			MSExecAuto({|X,Y| FINA040(X,Y)},aTitulos,3)
			
			If lMsErroAuto
				MostraErro()
			EndIf
			
			If lPccBxCr
				nPisBaseR := nPisBaseA
				nCofBaseR := nCofBaseA
				nCslBaseR := nCslBaseA
			EndIf
			
			If lIrPjBxCr
				nIrfBaseR := nIrfBaseA
			EndIf
	
			If ExistTemplate("GEMSE1Grv")
				ExecTemplate("GEMSE1Grv",.F.,.F.)
			EndIf
	
			dbCommit()
	
			If ExistTemplate("GEMSE5Grv")
				ExecTemplate("GEMSE5Grv",.F.,.F.)
			EndIf
			
			AtuSalBco( cBanco, cAgencia, cConta, SE5->E5_DTDISPO, SE5->E5_VALOR, "+" )
	
			//Atualiza Saldo do Titulo.
			If SE1->E1_TIPO $ MVRECANT+"/"+MVABATIM+"/"+MV_CRNEG
				AtuSalDup("-",SE1->E1_SALDO,SE1->E1_MOEDA,SE1->E1_TIPO,,SE1->E1_EMISSAO)
			Endif
			dbSelectArea("SE1")
			SE1->(dbSetOrder(nOrdNow))
			SE1->(dbGoto(nRecNow))
			If !lBxParc
				Return .f.
			EndIf
		Else
			Return .f.
		EndIf
	EndIf
Elseif lIntRm .and. lExterno
 	If SuperGetMv("MV_REC2TIT",,"2") == "1"  .and. nSalTit > 0 .and. (nSalTit < nValPadrao .Or. lVlrMaior)
		nValRec := nValRec + (nJuros +Iif(SE1->E1_MOEDA<=1,nCm,0)+nMulta-nDescont-nTotAbat+nAcresc-nDecresc)		
 	Endif  
Endif

If lFINAJURO
	Execblock("FINAJURO",.F.,.F.)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se saldo estava em outra moeda, caso estiver, converte valor ³
//³recebido pela taxa diaria da moeda												 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SE1->E1_MOEDA > 1 .Or. (cPaisLoc<>"BRA" .And. nMoedaBco > 1)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se Taxa Moeda ‚ contratada                             ³
	//³Permite diferenca menor que 0.01 na compara‡„o...               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc <> "BRA"
		nCalc := nValEstrang+(nDescont-nMulta-nJuros - nVA -nAcresc+nDecresc+nOtrga)
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Nao converte os valores no caso de compensacao entre carteiras ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty(SE1->E1_IDENTEE)
			nCalc := nValEstrang+xMoeda(nDescont-nMulta-nJuros - nVA -nAcresc+nDecresc,1,SE1->E1_MOEDA,dBaixa,4,,nTxMoeda)
		Else
			// Retirado Round() para evitar diferenca de 0.01 em baixa total no caso de correcao monetaria negativa.
			nCalc := nValestrang+xMoeda(nDescont-nMulta-nJuros - nVA -nAcresc+nDecresc+If(lPccBxCr,nPis+nCofins+nCsll,0)+Iif(lIrPjBxCr,nIrrf,0),nMoedaBco,SE1->E1_MOEDA,dBaixa,4,,nTxMoeda)
		EndIf
	Endif
	If (SE1->E1_SALDO+SE1->E1_ACRESC-SE1->E1_DECRESC) - nCalc >= 0.01
		nSaldo := SE1->E1_SALDO-nCalc
	Else
		nSaldo := 0
	Endif
Else
	// lExterno == .T. ==> CNAB
	If nValPadrao < 0	
		nSaldo := SE1->E1_SALDO
	Else
		nSaldo := SE1->E1_SALDO - nValPadrao
	EndIf
	If Round(NoRound(nSaldo,3),2) <= 0.00999 .and. ;
		IIf (lExterno, ( IIf(SuperGetMv("MV_ZERASE1",,"S") == "S",.T.,.F.) ),.T.)
		nSaldo := 0
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso o saldo restante  seja igual ao valor dos abatimentos,  ³
//³ considerar a baixa total do titulo.                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Str(nSaldo,16,2)=Str(nTotAbat,16,2)
	nSaldo := 0
Endif


//--------------------------------------------------------------------------------------
//Tolerância de Recebimento
nDescont := nDescont + nDecresc
nJuros 	 := nJuros + nAcresc

If nSaldo > 0
	nToler := SuperGetMv("MV_TOLERPG",,0)
	
	//Valor recebido a menor
	If nToler > 0 .And. nSaldo > 0
		If nSaldo <= nToler
			nDescont := nDescont + (nSaldo - nTotAbat)
			nSaldo	 := 0
		EndIf
	EndIf
	
	//Valor recebido a maior
	If nToler > 0 .and. nSaldo < 0
		nJuros 		:= nJuros + Abs(nSaldo)
		nValToler	:= Abs(nSaldo)
		nSaldo		:= nSaldo + Abs(nSaldo)
	Endif
Endif


//****Tratamento para integração do RM Classis x Protheus****
//caso a baixa seja do tipo "BOL" (bolsa de estudos) e o valor recebido seja 0
//gravo o saldo do título zerado para efetivar a baixa integral do mesmo
If FwHasEai("FINA070") .And. (AllTrim(SE1->E1_ORIGEM) $ "L|S|T" .Or. SE1->E1_IDLAN > 0)
	nPosBx := Ascan(aMotBx, {|x| AllTrim(SubStr(x,7,10)) == AllTrim(Upper(cMotBx))})
	If nPosBx > 0 
		If SubStr(aMotBx[nPosBx],1,3) == "BOL" //Baixa do tipo BOL - Bolsa de estudos
			//Zero o saldo caso a baixa seja do tipo BOL
			nSaldo := 0
		EndIf
	EndIf
EndIf

Begin Transaction
	RecLock("SE1")
	nSE1Rec := Recno()
	Replace E1_BAIXA	  With If(E1_BAIXA <= dBaixa, dBaixa, E1_BAIXA)
	Replace E1_LOTE	  With cLoteFin
	Replace E1_MOVIMEN  With dBaixa
	Replace E1_DESCONT  With nDescont
	Replace E1_MULTA	  With nMulta
	Replace E1_JUROS	  With nJuros
	
	If cPaisLoc == "BRA" 
		If lPccBxCr .And. !FwIsInCallStack("FA450CMP")
			nValrec += nPis + nCofins + nCsll
		EndIf
		PIS	:=nPis
		COFINS :=nCofins
		CSLL	:= nCsll
		
		If (lIrPjBxCr .or. (lImpBxCr .and. lF070Imp2 .and. lFa070Imp .and. nOldIrrf == 0))
			nValrec += nIrrf
			nValImp += nIrrf
		Endif
	EndIf

	If lFinSalTit .AND. FwIsInCallStack("FINA080")
		Replace E1_VALLIQ With nValrec + ExecBlock("FinSalTit", .F.,.F., 2)
	Else
		Replace E1_VALLIQ With nValrec
	Endif

	Replace E1_OK		With Iif(E1_OK == cMarca,"xx",cMarca)
	Replace E1_STATUS   With IIF(E1_STATUS != "R",Iif(nSaldo >= 0.01,"A","B"),"R")
	If cPaisLoc == "CHI"
		SE1->E1_OTRGA  := nOtrga
		SE1->E1_CAMBIO := SE1->E1_CAMBIO + nDifCambio
	Else
		Replace E1_CORREC   With nCm
	EndIf
	
	If ExistTemplate("GEMSE1Grv")
		ExecTemplate("GEMSE1Grv",.F.,.F.)
	EndIf
	
	SE1->(MsUnlock())
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava um registro para cada Movimenta‡„o Banc ria 			  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG
		lAdiantamento := .t.
	EndIf

	If nSaldo > 0 .And. nAcrescF > 0
		If nValRec < ((nTotJur+nAcrescF+nMulta)-nDescont)		
			nAcresc = nValRec - ((nTotJur+nMulta)-nDescont)
		Elseif nAcrescF > 0
			nAcresc = nAcrescF			
		EndIf  	
	Elseif nAcrescF > 0
		nAcresc = nAcrescF
	Else
		nAcresc = 0	
	EndIf

	// Controla saldo na compensacao do cheque
	If SuperGetMv("MV_SLDBXCR",,"B") == "C"
		// Soma o total recebido em cheque
		nSomaCheq := SomaCheqCr(.F.,SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE)
	Endif

	//Movimento Bancário
	If !(lRet := FA070Mov( lPadrao,lContabiliza,lAdiantamento,dDtCredito,@aBaixas,cArqEnt,cOcorr,nTxMoeda,nSomaCheq,aSeqSe5,@cSequencia,aHdlPrv,,oModelBxC, lMultNat))
		DisarmTransaction()
	EndIf
	
End Transaction

If lRet
	If lAtuSldNat .and. !lMultNat .AND. !IsInCallStack('Fa040Subst') .AND. SE5->E5_MOTBX != 'TIN'
		// Nao precisa atualizar a baixa dos abatimentos, pois o valor recebido jah eh liquido dos abatimentos
		If nSaldo = 0
			nValpadrao += nTotAbat
		Endif
		
		nValRealiz := nValRec - If(lPccBxCr,nPis+nCofins+nCsll,0) - Iif(lIrPjBxCr,nIrrf,0)
	
		If (SE1->E1_MOEDA <> 1) .and. (nMoedaBco <> 1)
			nValForeing := Round(NoRound(xMoeda(nValEstrang,nMoedaBco,1,dBaixa,3,nTxMoeda),3),2)
		ElseIf (SE1->E1_MOEDA <> 1) .and. (nMoedaBco == 1)
			nValForeing := nValRealiz
			nValRealiz  := nValEstrang
		Else
			nValForeing := nValEstrang
		EndIf
	
		AtuSldNat(SE1->E1_NATUREZ,dBaixa,SE1->E1_MOEDA,If(SE1->E1_TIPO $ MVPROVIS,"2","3"),"R", nValRealiz, nValForeing, If(SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG+"/"+MVPROVIS,"-","+"),,FunName(),"SE1",SE1->(Recno()))
	Endif
	
	dbSelectArea("SE1")
	nSalvRec	:= SE1->(RecNo())
	cNum	  	:= SE1->E1_NUM
	cPrefixo	:= SE1->E1_PREFIXO
	cParcela	:= SE1->E1_PARCELA
	cCliente	:= SE1->E1_CLIENTE
	cLoja   	:= SE1->E1_LOJA
	cTipoOr		:= SE1->E1_TIPO
	cTipo   	:= ""

	//------------------------------------------------------------------------------
	// Caso seja baixa de adiantamento, deverá ser estornado saldo 
	// bancário. Apenas Baixa que gere movimentacao bancaria	
	//------------------------------------------------------------------------------
	If !FwIsInCallStack("fA070Tit")
		If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG 
			If MovBcoBx(cMotBx, .T.) .And. !lGerChqAdt
				AtuSalBco( cBanco, cAgencia, cConta, dBaixa, nValRec, "-" )
			EndIf
			
			fa070Adiant( lPadrao, lContabiliza, IIF(cMotBx == "CEC", .T.,lGerChqAdt), @aBaixas, dDtCredito , nTxMoeda )
			
			If cPaisLoc == "COL"
				If FindFunction("FinProcITF") .And. FinProcITF( SE5->( Recno() ),1 ) .and. cTipoOr=='RA '
					FinProcITF( SE5->( Recno() ), 3, , .F.,, )
				EndIf
			EndIf
		EndIf
		
		If (!FN022SITCB(SE1->E1_SITUACA)[3]) .And. MovBcoBx(cMotBx, .T.) .And. !lAdiantamento .And. Empty( cLoteFin ) //Situacao de cobranca diferente de descontada
		
			//------------------------------------------------------------------------------
			// Gravar Saldo Bancário 
			//------------------------------------------------------------------------------
			If cPaisLoc <> "BRA"
				nMoedaBco := Iif(Type("nMoedaBco") == "U", Max(Posicione('SA6',1,xFilial('SA6')+cBanco+cAgencia+cConta,"A6_MOEDA"),1),nMoedaBco)
				AtuSalBco(cBanco,cAgencia,cConta,dDtCredito,xMoeda(nValRec-nSomaCheq,SE1->E1_MOEDA,nMoedaBco,,,nTxMoeda),"+")
			Else
				AtuSalBco(cBanco,cAgencia,cConta,dDtCredito,nValRec-nSomaCheq,"+")
			EndIf
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ PTO DE ENTRADA para tratamento das datas de vencto do ISS	  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF lF070DISS
		ExecBlock("F070DISS",.f.,.f.)
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Baixar titulos de abatimento se for baixa total				  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF nSaldo == 0
		//Atualiza status do adiantamento de viagem
		If (ALLTRIM(SE1->E1_ORIGEM) == "FINA677")
			FINATURES(SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO+E1_CLIENTE+E1_LOJA),.T.,SE1->E1_ORIGEM,"R")
		Endif
	
		If Select("__SE1") == 0
			SumAbatRec("","","",1,"")
		Endif
		dbSelectArea("__SE1")
		__SE1->(dbSetOrder(2))
		__SE1->(dbSeek(xFilial("SE1")+cCliente+cLoja+cPrefixo+cNum+cParcela))
		If lTitpaiSE1
	 		If (nOrdTitPai:= OrdTitpai()) > 0
				__SE1-> (DbSetOrder(nOrdTitPai))
				If	DbSeek(xFilial("SE1")+cPrefixo+cNum+cParcela+cTipoOr+cCliente+cLoja)
					bWhile := {|| !Eof() .And. Alltrim(XFILIAL("SE1")+E1_TITPAI) == Alltrim(xFilial("SE1")+cPrefixo+cNum+cParcela+cTipoOr+cCliente+cLoja) }
				Else
					__SE1->(dbSetOrder(2))
	  				__SE1->(dbSeek(xFilial("SE1")+cCliente+cLoja+cPrefixo+cNum+cParcela))
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verificações sobre a transferência de documento com o ISS na origem ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cFilOrgTr := FilISSTran() 
				If !Empty( cFilOrgTr )
					nForIss := 2// -Somente para documentos que foram transferidos deixando o ISS na origem
				EndIf
			Endif
		Endif
	
		For nX := 1 To nForIss
	
			If nX == 2
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Alterações para efetuar a busca do ISS na filial de origem ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lTitpaiSE1 .And. nOrdTitPai == 0
					__SE1->( dbSetOrder( 2 ) )
					__SE1->(dbSeek(cFilOrgTr+cCliente+cLoja+cPrefixo+cNum+cParcela))
					bWhile := {|| !EOF() .And. E1_FILIAL==cFilOrgTr .And. E1_CLIENTE = cCliente	.And. E1_LOJA = cLoja .And. E1_PREFIXO=cPrefixo .And. E1_NUM == cNum .And. E1_PARCELA==cParcela }
				Else
					__SE1->(DbSeek(cFilOrgTr+cPrefixo+cNum+cParcela+cTipoOr+cCliente+cLoja))
					bWhile := {|| !Eof() .And. Alltrim(cFilOrgTr+E1_TITPAI) == Alltrim(cFilOrgTr+cPrefixo+cNum+cParcela+cTipoOr+cCliente+cLoja) }
				EndIf
			EndIf
	
			While Eval(bWhile)
				If lTitpaiSE1
					If !Empty(E1_TITPAI) .and.  (Alltrim(E1_TITPAI)!=Alltrim(cPrefixo+cNum+cParcela+cTipoOr+cCliente+cLoja))
						DbSkip()
						Loop
					EndIf
					If E1_TIPO $ "IS-/ISS" .And. IIF(IsInCallStack("FINA630"), !lTrfISSf, .F.)
						DbSkip()
						Loop
					EndIf
				EndIf
		
				//Trabalha somente com o ISS da filial de origem, somente em casos de documento transferido
				If nX == 2 .And. E1_TIPO <> MVISABT
					DbSkip()
					Loop
				EndIf
		
				IF E1_TIPO $ MVABATIM+"/"+MVIRABT+"/"+MVINABT+"/"+MVPIABT+"/"+;
					MVCFABT+"/"+MVCSABT+"/"+MVFUABT //adicionado a variável MVFUABT, pois a variável MVABATIM não está retornando FU-
					RecLock("__SE1")
					Replace E1_SALDO	With 0
					Replace E1_BAIXA	With dBaixa
					Replace E1_LOTE	With cLoteFin
					Replace E1_MOVIMEN With dBaixa
					Replace E1_STATUS  With "B"
					Replace E1_SDACRES With 0
					Replace E1_SDDECRE With 0
		
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Gravar o titulo que baixou o AB- para evitar estornos de ³
					//³abatimentos baixados por outras rotinas. Evita que um AB-³
					//³baixado pelo FINA070 / 110 seja estornado indevidamente  ³
					//³pelo FINA330, que gera erro na composicao do saldo do    ³
					//³titulo principal com abatimento.                         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If Empty(SE1->E1_TITPAI) .OR. (!MV_CRNEG $ SE1->E1_TITPAI .AND. !MVRECANT $ SE1->E1_TITPAI)
						Replace E1_TITPAI	With (cPrefixo + cNum + cParcela + cTipoOr + cCliente + cLoja)
					Endif
		
					If lF070GrvHis .and. E1_TIPO $ MVIRABT
						ExecBlock("F070GrvHis",.F.,.F.)
					ENDIF
		
					If lAtuSldNat
						AtuSldNat(E1_NATUREZ, E1_BAIXA, E1_MOEDA, "3", "R", E1_VALOR, E1_VALOR, "-",,FunName(),"SE1",SE1->(Recno()),nOpcx)
					Endif
		
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Carrega variavies para contabilizacao dos    ³
					//³ abatimentos (impostos da lei 10925).         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If E1_TIPO == MVPIABT
						VALOR5 := E1_VALOR
					ElseIf E1_TIPO == MVCFABT
						VALOR6 := E1_VALOR
					ElseIf E1_TIPO == MVCSABT
						VALOR7 := E1_VALOR
					Endif
					MsUnlock()
				EndIF
				dbSkip()
			Enddo
		Next nX
		If lF070GerAb
			IF SE5->E5_TIPODOC $ "VL.BA" .AND. SE5->E5_DATA == dBaixa .and. FUNNAME()=="FINA080"
				dbSelectArea("SE5")
				Reclock("SE5",.F.)
				E5_TESTE := SE1->E1_PARCELA + SE5->E5_SEQ
				E5_VRETIRF := u_F70ALTABAT()
				E5_BASEIRF := SE5->E5_VALOR  + nTotAbImp+Iif(lF070IRAB, Execblock("FIN70IRAB",.F.,.F.),0)
				MsUnlock()
				dbSelectArea("SE1")
			ENDIF
		Endif
		__SE1->(dbSetOrder(1))
	ElseIf lF070GerAb
		nSaldo -= EXECBLOCK("F070GerAb",.F.,.F., {cCliente+cLoja+cPrefixo+cNum+cParcela, dBaixa , cLoteFin , cTipoOr, } )
	Endif
	
	dbSelectArea("SE1")
	SE1->(dbGoto(nSE1Rec))
	
	IF nSaldo == 0
		If lFin70BxIr
			Execblock("Fin70BxIr", .F.,.F.)
		Endif
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona no registro de natureza									  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SED")
	SED->(dbSeek(xFilial("SED")+SE1->E1_NATUREZ))
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza o Cadastro de Clientes 									  ³
	//³ A pesquisa pelo SL1 e' do Loja no caso de adm <> "R$/CH"     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SA1")
	SA1->(DbSetOrder(1))
	If dbSeek(xFilial("SA1")+SE1->E1_CLIENTE+SE1->E1_LOJA)
		nValClient := nValPadrao
		IF SE1->E1_MOEDA > 1
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Caso a Moeda seja > 1, converte o valor para atualiza‡„o do  ³
			//³ cadastro do Cliente a partir do valor da moeda estrangeira   ³
			//³ convertida p/ moeda 1 na Data de Emiss„o do t¡tulo, pois pode³
			//³ ser efetuada uma baixa informando taxa contratada.           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nVlEstOri := nValEstrang-(Round(NoRound(xMoeda(nJuros + nVA +nMulta-nDescont-nOtrga,nMoedaBco,SE1->E1_MOEDA,dBaixa,3,,nTxMoeda),3),2))
			nValClient:= Round(NoRound(xMoeda(nVlEstOri,SE1->E1_MOEDA,nMoedaBco,SE1->E1_EMISSAO,3,nTxMoeda),3),2)
		EndIf
		If SuperGetMv("MV_SLDBXCR",,"B") == "C"
			nValClient := nValClient-nSomaCheq
		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Para o SIGALOJA, executa a funcao de comissao por ³
		//³baixa chamada Lj440ProcB (LOJA440)                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nModulo == 12 .Or. nModulo == 72 .Or. (nModulo == 5 .And. AllTrim(Funname()) == "FATA701") // SIGALOJA //SIGAPHOTO // VENDA DIRETA
			If SuperGetMV("MV_TPCOMLJ",,"B") == "O" .AND. ComisBx( TrazCodMot(cMotBx) ) .AND. SE1->E1_COMIS1 > 0				
				Fa440CalcB(aBaixas,lJuros,lDesconto,"FINA070","-",,,.T.,nSE1Rec)
				lLj440Proc := .T.
			EndIf
		EndIf
		If lAdiantamento
			AtuSalDup("+",nValClient,nMoedaBco,SE1->E1_TIPO,,SE1->E1_EMISSAO,,lBloqSa1)
			If SuperGETMV("MV_TPCOMIS",,"O") == "O"  .and. ComisBx( TrazCodMot(cMotBx) ) .AND. !lLj440Proc .AND. lVendedor
				Fa440CalcB(aBaixas,lJuros,lDesconto,"FINA070","-",,,.T.,nSE1Rec)
			Endif
		ElseIf FunName() <> "FINA074" 
			AtuSalDup("-",nValClient,1,SE1->E1_TIPO,nTxMoeda,SE1->E1_EMISSAO,nCm,lBloqSa1)	
			If lBloqSa1	
		    	RecLock("SA1")
				Replace A1_NROPAG With A1_NROPAG+1  //Numero de Duplicatas
			
				nAtraso:=dBaixa-SE1->E1_VENCTO
				If nAtraso > 1
					IF Dow(SE1->E1_VENCTO) == 1 .Or. Dow(SE1->E1_VENCTO) == 7
						IF Dow(dBaixa) == 2 .and. nAtraso <= 2
							nAtraso := 0
						EndIF		
					EndIF 
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza atraso medio SA1->A1_ATR                            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If 	SE1->E1_VENCREA < dBaixa .AND. SA1->A1_ATR <> 0
				 		If SE1->E1_SALDO <> SE1->E1_VALOR
				   			SA1->A1_ATR := SA1->A1_ATR - nValRec 
				   		ElseIf SA1->A1_ATR := SA1->A1_ATR + SE1->E1_SALDO
				   			SA1->A1_ATR := SA1->A1_ATR - nValRec
				   		EndIf
				  	EndIf
				  	
				  	If SE1->E1_VENCREA < dBaixa .AND. SA1->A1_ATR == 0
				   		SA1->A1_ATR := SA1->A1_ATR + SE1->E1_SALDO
				   		SA1->A1_ATR := SA1->A1_ATR - nValRec
				 	EndIf
					nAtraso:=IIF(nAtraso<0,0,nAtraso)
					If SA1->A1_MATR < nAtraso
						Replace A1_MATR With nAtraso
					EndIf
				Endif
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza Atraso M‚dio.  Revisao em 07/12/95					     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (SE1->E1_BAIXA - SE1->E1_VENCREA) > 0
					SA1->A1_PAGATR := A1_PAGATR+SE1->E1_VALLIQ   // Pagamentos Atrasados
				Endif
			
				SA1->A1_METR	 :=	(A1_METR * (A1_NROPAG-1) + (SE1->E1_BAIXA - SE1->E1_VENCREA)) / (A1_NROPAG)
				
				SA1->(MsUnlock())	// Destrava SA1 apos alteracoes...
			EndIf
			
			If SuperGETMV("MV_TPCOMIS",,"O") == "O" .and. ComisBx( TrazCodMot(cMotBx) ) .AND. !lLj440Proc .AND. lVendedor
				Fa440CalcB(aBaixas,lJuros,lDesconto,Iif(!empty(SE1->E1_NUMLIQ),,"FINA070"),,,,.T.,nSE1Rec)
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ PONTO DE ENTRADA 									  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lSE3FI070
				ExecBlock('SE3FI070',.f.,.F.)
			Endif
			
		Endif
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Complementa grava‡Æo da baixa tit. principal  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE1")
	SE1->(dbGoto(nSE1Rec))
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ PONTO DE ENTRADA 									  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lSE3F070
		ExecBlock('SE3F070',.f.,.F.)
	Endif
	
	RecLock("SE1")
	Replace E1_SALDO With nSaldo
	If nSaldo > 0 .And. nAcrescF > 0
		If nValRec < ((nTotJur+nAcrescF+nMulta)-nDescont)
			Replace E1_SDACRES  With nAcrescF - (nValRec - ((nTotJur+nMulta)-nDescont))
		Else
			Replace E1_SDACRES  With 0
		EndIf
	Else
		Replace E1_SDACRES  With 0
	EndIf
	Replace E1_SDDECRE  With 0
	Replace E1_STATUS   With IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")
	
	nToler := SuperGetMv("MV_TOLERPG",,0)
	
	If nToler > 0 .And. nSaldo > 0
		If nSaldo <= nToler
			Replace E1_DESCONT	With E1_DESCONT+nSaldo
			Replace E1_SALDO		With 0
			Replace E1_STATUS   With IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")
			nDescont := E1_DESCONT
		EndIf
	EndIf
	
	If nToler > 0 .and. nSaldo < 0
		Replace E1_SALDO		With E1_SALDO+Abs(nSaldo)
		Replace E1_JUROS		With E1_JUROS+Abs(nSaldo)
		Replace E1_STATUS   With IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")
		nValToler := Abs(nSaldo)
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se saldo for menor que zero, for‡a o seu zeramento pois ocorre de o u-³
	//³suario realmente receber o valor em real a maior que o saldo em dolar ³
	//³gerando uma cota‡„o a maior e consequente saldo negativo, indevido    ³
	//³SOMENTE PARA BAIXA MANUAL.                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SE1->E1_SALDO < 0 .and. !lExterno 		// lExterno == .T. == CNAB
		Replace E1_SALDO With 0
		Replace E1_STATUS   With IIF(E1_STATUS != "R",Iif(E1_SALDO >= 0.01,"A","B"),"R")
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava "Nosso Numero" apenas se o campo for vazio e a variavel³
	//³ possuir conte£do. A variavel  "cNsNum" vem preenchida somente³
	//³ quando esta fun‡„o fa070grv for chamada pelo programa FINA200³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(cNsNum) .and. Empty(SE1->E1_NUMBCO)
		SE1->E1_NUMBCO := cNsNum
	Endif
	
	//--- Verifica se o título está nas tabelas do Telecobrança e realiza a atualização do seu saldo e status
	If ExistFunc("TK180BxAtd")
		TK180BxAtd(SE1->E1_PREFIXO, SE1->E1_NUM, SE1->E1_PARCELA, SE1->E1_TIPO, SE1->E1_CLIENTE, SE1->E1_LOJA, SE1->E1_FILIAL)
	Endif
	//
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Executa funcao do PLS para gerar juros para      ³
	//³descontar no mes seguinte                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Substr(SE1->E1_ORIGEM,1,3) == "PLS"
		PLS510JR()
	Endif
	
	nIss := 0
	//Gravo os titulos de impostos Pis Cofins Csll quando controlados pela baixa
	// Os titulos de impostos devem ser desconsiderados quando C/C cuja moeda seja diferente da moda corrente
	If cPaisLoc == "BRA" .and. lPCCBxCR .and. lRetParc
		//Imposto PCC sempre na moeda 1
		If FXMultSld()
			If SA6->A6_MOEDA <= 1
				FGrvPccRec(@nPis,@nCofins,@nCsll,nSalvRec,.F.,lRetParc,cSequencia,"FINA070",1)
			EndIf
	    Else
			FGrvPccRec(@nPis,@nCofins,@nCsll,nSalvRec,.F.,lRetParc,cSequencia,"FINA070",1)
	    EndIf
	Endif
	If cPaisLoc == "BRA" .and. lIrPjBxCr .and. lRetParc
		If FXMultSld()
			If SA6->A6_MOEDA <= 1
				FGrvIrRec(@nIrrf,nSalvRec,.F.,cSequencia,"FINA070",SE1->E1_MOEDA)
			EndIf
	    Else
			FGrvIrRec(@nIrrf,nSalvRec,.F.,cSequencia,"FINA070",SE1->E1_MOEDA)
	    EndIf
	Endif
	
	If lf70GrSe1				// Ponto de entrada no final da baixa do titulo
		Execblock("F70GRSE1",.F.,.F.,{cOcorr})
	Endif
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Executa as verificacoes e providencias do modulo ³
	//³Gestao Educacional.                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SuperGetMV( "MV_ACATIVO",,.F. )
		FA070Aca()
	Endif
	
	//
	// Template GEM - Se todos os titulos foram pagos (E1_SALDO == 0 ) deve atualizar o STATUS do contrato.
	//
	If ExistTemplate("GMUpdStatContr")
		ExecTemplate("GMUpdStatContr",.F.,.F.,{SE1->E1_NUM ,SE1->E1_SERIE ,SE1->E1_PREFIXO } )
	EndIf
	
	//
	//Função Específica do Modulo Sigapls para atualizar Status de Guias Compradas
	//
	If GetNewPar("MV_PLSATIV",.F.)
		PL090TITCP(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,"1")
	EndIf

EndIf

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070MOV

Grava movimento de baixa CR.
Arquivo anterior: FINXATU.PRX

@Author	Wagner Xavier 
@since	06/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function FA070Mov( lPadrao,lContabiliza,lAdiantamento,dDtCredito,aBaixas,cArqEnt,;
						 cOcorr, nTxMoeda,nSomaCheq,aSeqSe5,cSequencia,aHdlPrv,cProc,oModelBxC, lMultNat)
Local i
Local cTpDoc		:= ""
Local cAlias		:= ALIAS()
Local cHistMov		:= ""
Local lSpbInUse		:= SpbinUse()
Local bCampo		:= {|| }
Local nValMov		:= 0
Local nValCalc		:= 0
Local nX			:= 0
Local cSldBxCr		:= SuperGetMv("MV_SLDBXCR",,"B")
Local lSaldoChq		:= (cSldBxCr =="C")
Local nMoedaBco		:= 1
Local nIndexOrd		:= 0
Local nTamSeq		:= TamSX3("E5_SEQ")[1]
Local nCont			:= 0
Local lSaldoChq		:= (cSldBxCr =="C")
//Reestruturacao SE5
Local oModelBxR		:= NIL	//FWLoadModel("FINM010") //Model de baixas a receber
Local oModelBxRA	:= NIL	//FWLoadModel("FINM010")	//Model de baixas a receber auxiliar
Local cLog			:= ""
Local cCamposE5		:= ""
Local dDataAux		:= CTOD(" / / ")
Local nRecSE5		:= 0
Local aRecnos 		:= {}
Local aAuxFK6		:= {}
Local nRecOrig		:= 0
Local lDestroy		:= .T.
Local lRet			:= .T.
Local cFormPagto	:= ""
//Reestruturacao SE5
Local lAcolsType	:= Type("aCols") == "A"
Local lFinm010	:= ExistBlock("FINM010")

//Variavel para compatibilidade do MVC
Private n			:= 0

Default nSomaCheq 	:= 0
Default aSeqSe5 	:= {}
Default cSequencia	:= Replicate("0",nTamSeq)
Default aHdlPrv		:= {}
Default cProc		:= ""
Default oModelBxC	:= NIL
Default lMultNat	:= .F.

nIrrf := If( Type("nIrrf") != "N", 0, nIrrf )

nValToler := Iif(nValToler==Nil,0,nValToler)
lAdiantamento := Iif( lAdiantamento=Nil,.f.,lAdiantamento )

cArqEnt		:= Iif(cArqEnt==Nil," ",cArqEnt)
cOcorr		:= Iif(cOcorr==Nil,"  ",cOcorr)
cFormPagto	:= If(Type("cFormaPag") != "C","",cFormaPag)

nJurosCalc	:= If( Type("nJurosCalc") != "N", 0, nJurosCalc )
nMultaCalc	:= If( Type("nMultaCalc") != "N", 0, nMultaCalc )
nDescCalc	:= If( Type("nDescCalc") != "N", 0, nDescCalc )

cModSpb		:= If( Type("cModSpb") != "C", "1", cModSpb )
nVa			:= IIf( Type('nVA') != 'N', 0, nVa )

If lAdiantamento
	Return .T.
EndIf

cSequencia := FinSeqSe5(/*cPrefixo*/,/*cNum*/,/*cParcela*/,/*cTipo*/,.T. /*lQuery*/)

//Desenvolvo aqui a logica nova da reestruturacao da SE5
//Instancio os models, sub models e models auxiliares que vou utilizar na gravacao, passando como parametro para a funcao Fa070GrvSe5
IF oModelBxC != NIL
	oModelBxR := oModelBxC
	lDestroy := .F.
ELSE
	oModelBxR := FWLoadModel("FINM010")	//aqui kco
ENDIF

oModelBxR:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
oModelBxR:Activate()
oModelBxR:SetValue("MASTER","E5_GRV",.T.) //habilita gravação de SE5
oModelBxR:SetValue("MASTER","NOVOPROC", .T. ) //Novo processo

For i := 1 To 8
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza a Movimenta‡„o Banc ria							 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nValCalc := 0
	If i == 1
		nValMov  := nValRec 						//sitcob
		cTpDoc  := Iif(FN022SITCB(SE1->E1_SITUACA)[3],"V2",Iif((Empty(cLoteFin).AND. !FwIsInCallStack("FA450CMP")),"VL","BA"))
		If !MovBcoBx(cMotBx,.T.) .And. !AllTrim(SE1->E1_SITUACA)$"2|7"
			cTpDoc := "BA"
		Endif
		// Controla saldo na compensacao do cheque
		If cSldBxCr == "C"
			// Do valor recebido deve ser subtraido o total pago em cheque, pois o valor referente a
			// baixa efetuada em cheque sera movimentado apenas quando o cheque for compensado.
			nValMov := nValRec-nSomaCheq 
		Endif
		cHistMov:= Iif(Empty(cHist070),OemToAnsi(STR0002),cHist070) //"Valor recebido s/ titulo"
	Elseif i == 2
		nValMov  := nSomaCheq
		cTpDoc  := "BA"
	Elseif i == 3
		nValMov  := nMulta 
		nValCalc := nMultaCalc
		cTpDoc  :=IIF(FN022SITCB(SE1->E1_SITUACA)[3],"M2","MT")	//sitcob
		cHistMov:=OemToAnsi( STR0003 )  //"Multa s/Receb.Titulo"
	Elseif i == 4
		nValMov  := nCM 
		nValCalc := nCM
		cTpDoc  :=IIF(FN022SITCB(SE1->E1_SITUACA)[3],"C2","CM")	//sitcob
		cHistMov:=OemToAnsi( STR0004 ) //"Correcao Monet s/Receb.Titulo"
	Elseif i == 5
		nValMov  := nDescont
		nValCalc := nDescCalc
		cTpDoc  :=IIF(FN022SITCB(SE1->E1_SITUACA)[3],"D2","DC")   //FN022SITCB(SE1->E1_SITUACA)[3] = Cobranca descontada
		cHistMov:=OemToAnsi( STR0005 ) //"Desconto s/Receb.Titulo"
	Elseif i == 6
		nValMov  := nValToler
		nValCalc := nValToler
		cTpDoc  := "TL"
		cHistMov:= OemToAnsi( STR0006 ) //"Toler Receb. s/ Titulo"
	Elseif i == 7
		nValMov  := nJuros
		nValCalc := nJurosCalc
		cTpDoc  :=IIF(FN022SITCB(SE1->E1_SITUACA)[3],"J2","JR")	//sitcob
		cHistMov:=OemToAnsi( STR0007 ) //"Juros s/Receb.Titulo"
		
	Elseif i == 8
		nValMov  := nVA
		nValCalc := nVA
		cTpDoc  := "VA"
		cHistMov:= OemToAnsi( STR0027 )		//"Valores Acessórios"
	Endif
	// Grava o movimento bancario, se o campo for diferente de 0 ou se
	// for o valor recebido verifica se o valor nao foi pago totalmente em cheque,
	// para nao haver um registro do cheque e um registro com valor 0 da diferenca
	If nValMov != 0 .Or. ;		//Valor do movimento não é zero (positivo ou negativo)
		(i == 1 .And. (cSldBxCr != "C" .or. (nValMov == 0 .And. nDescont > 0) )) .or. ; //Baixa por desconto
		 i == 8				//Se for VA
		
		If i == 2
			If lAcolsType .And. !Empty(aCols)
				// Para cada cheque, gera um movimento bancario
				For nX := 1 To Len(aCols)
					// Se o cheque nao estiver deletado, os dados forem validos
					If !aCols[nX][Len(aCols[1])]	.And.;
						!Empty(aCols[nX][1])		.And.;
						!Empty(aCols[nX][2])		.And.;
						!Empty(aCols[nX][3])		.And.;
						!Empty(aCols[nX][4])		.And.;
						!Empty(aCols[nX][5])		.And.;
						!Empty(aCols[nX][6])		.And.;
						!Empty(aCols[nX][7])		.And.;
						!Empty(aCols[nX][8])		.And.;
						!Empty(aCols[nX][9])
						// Se o identificador de que o cheque ja foi utilizado na baixa estiver diferente de Sim,
						// gera o movimento, devido as baixas parciais, pois nas baixas futuras esses cheques nao
						// podem mais serem utilizados
						If aCols[nX][15] != "Sim"
							// Gera nova sequencia, para o caso do cancelamento apenas da baixa do valor recebido
							// em cheque nao cancelar todas as baixas
							cHistMov:= "Rec Ch-bco/ag/ch " + aCols[nX][1]+"/"+aCols[nX][2]+"/"+aCols[nX][4]
					  		bCampo := { || aCols[nX][6] } // Valor Ref. Baixa
							cSequencia := Soma1(cSequencia,nTamSeq)
							nValMov := Eval(bCampo)
					  		Fa070GrvSe5(cBanco,cAgencia,cConta,dBaixa,nValMov,lPadrao,lContabiliza,cTpDoc,cHistMov,;
											cLoteFin,cMotBx,nValEstrang,cSequencia,lSpbInUse,cModSpb,dDtCredito,cArqEnt,;
											cOcorr,nTxMoeda,i,nJuros,nMulta,nCm,nDescont,aBaixas,,nSomaCheq,oModelBxR,oModelBxRA,cProc,,@cCamposE5,nVa,,cFormPagto, lMultNat)
							//Adiciona a sequencia para ser utilizado na gravacao do movimento do cheque.
							
							IF !empty(cCamposE5) .AND. !(nX == Len(aCols))
								cCamposE5 += "}|"
							endIF
							Aadd(aSeqSe5,cSequencia)
							dbSelectArea("SEF")
							SEF->(dbSetOrder(3))

							//>> Localizacao e marcacao do cheque. Processo de baixa.
							nIndexOrd := SEF->( IndexOrd() )
							SEF->(dbSetOrder( 1 ))
							if SEF->( MsSeek(xFilial("SEF") +;
      										aCols[nX][1]   + ; //Banco
							                aCols[nX][2]   + ; //Agencia
							                aCols[nX][3]   + ; //Conta
							                aCols[nX][4] ) )   //Numero do Cheque
								If !aCols[ nX ][ Len(aCols[ nX ]) ] //Se nao estiver deletado e ...
									RecLock("SEF", .F.)
									SEF->EF_USADOBX := "S"
									SEF->EF_SEQUENC := cSequencia
								Endif
							endif
							SEF->( dbSetOrder( nIndexOrd ) )
							//<< Localizacao e marcacao do cheque. Processo de baixa.

						Else
							//Adiciona uma sequencia auxiliar para o cheque que está vinculado a outro título, para
							//que o array fique com a mesma quantidade do aCols na gravação dos cheques.
							Aadd(aSeqSe5,Replicate("0",nTamSeq))
						Endif
					else
						//Adiciona uma sequencia auxiliar para o cheque que está vinculado a outro título, para
						//que o array fique com a mesma quantidade do aCols na gravação dos cheques.
						Aadd(aSeqSe5,Replicate("0",nTamSeq))
					Endif
				Next
			Else
				dbSelectArea("SEF")
				SEF->(dbSetOrder(3))
				SEF->(MsSeek(xFilial("SEF")+SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)))
				While SEF->(!Eof()) .And.;
						SEF->(EF_FILIAL+EF_PREFIXO+EF_TITULO+EF_PARCELA+EF_TIPO) ==;
						xFilial("SEF")+SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)
					If (SEF->EF_FORNECE == SE1->E1_CLIENTE .Or.;
						SEF->EF_CLIENTE == SE1->E1_CLIENTE) .And.;
						!Empty(SEF->EF_NUM)
						If SEF->EF_USADOBX != "S"
							// Gera nova sequencia, para o caso do cancelamento apenas da baixa do valor recebido
							// em cheque nao cancelar todas as baixas
							cHistMov:= "Rec Ch - bco/ag/ch " + SEF->(EF_BANCO+"/"+EF_AGENCIA+"/"+EF_NUM)
					  		nValMov := SEF->EF_VALORBX
							cSequencia := Soma1(cSequencia,nTamSeq)
					  		Fa070GrvSe5(cBanco,cAgencia,cConta,dBaixa,nValMov,lPadrao,lContabiliza,cTpDoc,cHistMov,;
											cLoteFin,cMotBx,nValEstrang,cSequencia,lSpbInUse,cModSpb,dDtCredito,cArqEnt,;
											cOcorr,nTxMoeda,i,nJuros,nMulta,nCm,nDescont,aBaixas,,nSomaCheq,oModelBxR,oModelBxRA,;
											cProc,,@cCamposE5,nVa,nValMov,cFormPagto, lMultNat)
							//Adiciona a sequencia para ser utilizado na gravacao do movimento do cheque.
							Aadd(aSeqSe5,cSequencia)
							// Grava o identificador de que o cheque ja foi utilizado na baixa, devido as
							// baixas parciais, pois nas baixas futuras esses cheques nao podem mais serem utilizados
							RecLock("SEF",.F.)
							SEF->EF_USADOBX := "S"
							SEF->EF_SEQUENC := cSequencia
						Else
                     //Adiciona uma sequencia auxiliar para o cheque que está vinculado a outro título, para
                     //que o array fique com a mesma quantidade do aCols na gravação dos cheques.
							Aadd(aSeqSe5,Replicate("0",nTamSeq))
						Endif
					EndIf
					SEF->(dbSkip())
				EndDo
				dbSelectArea(cAlias)
			Endif
		Else
			If AllTrim(Upper(SE1->E1_ORIGEM)) <> "FINA074" .or. (cPaisLoc$"ARG|ANG|COL|MEX|PER" .And. cTpDoc<> "CM")
				// Este tratamento é para gerar "n" vezes o lançamento bancario de acordo
				// com acrescimo/decrescimo
                If i == 5 .Or. i == 7
					IF lF070MV1
						aHdlAux := ExecBlock("F070MV1",.F.,.F.,{i,aBxAcr,aBxDec,cBanco,cAgencia,cConta,dBaixa,nValMov,;
							                              lPadrao,lContabiliza,cTpDoc,cHistMov,cLoteFin,cMotBx,nValEstrang,;
							                              cSequencia,lSpbInUse,cModSpb,dDtCredito,cArqEnt,cOcorr,nTxMoeda,i,;
							                              nJuros,nMulta,nCm,nDescont,aBaixas,aHdlPrv})
					    If Valtype(aHdlAux) == "A"
							aHdlPrv	:= aClone(aHdlAux)
						EndIf
					EndIf
				ENDIF
				
				Fa070GrvSe5(cBanco,cAgencia,cConta,dBaixa,nValMov,lPadrao,lContabiliza,cTpDoc,cHistMov,;
						cLoteFin,cMotBx,nValEstrang,cSequencia,lSpbInUse,cModSpb,dDtCredito,cArqEnt,;
						cOcorr,nTxMoeda,i,nJuros,nMulta,nCm,nDescont,aBaixas,,nSomaCheq,oModelBxR,oModelBxRA,cProc,,@cCamposE5,nVa,nValCalc,cFormPagto,lMultNat)
						
			EndIf
		Endif
	EndIf
Next i

If !lFinm010
	If !Empty(cCamposE5)
		cCamposE5 += "}"
		oModelBxR:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
	EndIf
Endif

//Grava os dados
If (lRet := oModelBxR:VldData())
	oModelBxR:CommitData()	
	//Pega o Recno da SE5 referente a baixa principal e reposiciona para atualizar o valor com tratamento do IR
	aAdd(aRecnos, oModelBxR:GetValue( "MASTER", "E5_RECNO" ))
	For nX := 1 to Len(aRecnos)
		nRecSE5 := aRecnos[nX]
  		nRecOrig := nRecSE5
		If nRecSE5 > 0 
			SE5->( DbGoTo( nRecSE5 ) )
			FGSFQIRCR(nIrrf,nValrec,cSequencia,nDescont,nJuros,nMulta)
	   	Endif
	Next nX
 	If !oModelBxR:GetModel('FK6DETAIL'):IsEmpty() //precisa dos recnos da FK6, para composição do abaixas para calculo da comissão 
  		aAuxFK6 := FK6SE5Recs()
  		For nX := 1 to Len(aAuxFK6)
   			aAdd(aRecnos, aAuxFK6[nX])
  		Next nX
 	Endif 
	
	For nX := 1 to Len(aRecnos)
		nRecSE5 := aRecnos[nX]
		If nRecSE5 > 0 
			SE5->( DbGoTo( nRecSE5 ) )
			//Utilizado na rotina de comissão na baixa
	 		If !MV_CRNEG $ SE1->E1_TIPO .And. !MV_CPNEG $ SE1->E1_TIPO
				aAdd( aBaixas, { SE5->E5_MOTBX, SE5->E5_SEQ, nRecSE5 } )
			Endif
	   	Endif
	Next nX	

 	SE5->(DbGoTo(nRecOrig))

Else

    cLog := cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_IDFIELDERR]) + ' - '
    cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_ID]) + ' - '
    cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_MESSAGE])        	
    
    Help( ,,"M010VLDI5",,cLog, 1, 0 )
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PONTO DE ENTRADA			                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If lSE5FI070
	aRecnos:= FK6SE5Recs()
	aAdd(aRecnos, oModelBxR:GetValue( "MASTER", "E5_RECNO" ))
	For nX := 1 To Len( aRecnos )
		SE5->( DbGoto( aRecnos[nX] ) )						
		ExecBlock('SE5FI070',.f.,.F.)		
	Next nX
Endif

oModelBxR:DeActivate()

//Só destruo o Model caso o FwLoadModel tenha sido feito nesta função
IF lDestroy
	oModelBxR:Destroy()
	oModelBxR := Nil
Endif

DesFK6Recs()
	
If ValType(oModelBxRA) != 'U'
	oModelBxRA:DeActivate()
	oModelBxRA:Destroy()
	oModelBxRA := Nil
EndIf

dbSetOrder( 1 )
dbSelectArea(cAlias)

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070GRVSE5

Grava movimento de baixa CR (SE5).
Arquivo anterior: FINXATU.PRX

@Author	Claudio D. de Souza
@since	05/11/2003
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa070GrvSe5(cBanco,cAgencia,cConta,dBaixa,nValor,lPadrao,lContabiliza,cTpDoc,cHistMov,cLoteFin,;
							cMotBx,nValEstrang,cSequencia,lSpbInUse,cModSpb,dDtCredito,cArqEnt,;
							cOcorr,nTxMoeda,i,nJuros,nMulta,nCm,nDescont,aBaixas,cRecPag,nSomaCheq,;
							oModelBxR,oModelBxRA,cProc,cChaveSEF,cCamposE5,nVa,nValCalc,cFormPagto, lMultNat)

Local nRetencao		:= SA6->A6_RETENCA
Local dDataDisp		:= SE5->E5_DATA
Local nCont			:= 0

//Controla o Pis Cofins e Csll na baixa (1-Retem PCC na Baixa ou 2-Retem PCC na Emissão(default))
Local lPccBxCr		:= FPccBxCr()
//Controla IRPJ na baixa
Local lIrPjBxCr		:= FIrPjBxCr()
Local cModRetPIS	:= SA1->A1_ABATIMP
Local nVlMinImp		:= GetNewPar("MV_VL10925",5000)
Local lAplVlMin		:= .T.
Local nBaseRet		:= 0  //Base de retencao
Local nLoop			:= 0

Local lFa070tit		:= FwIsInCallStack("Fa070Tit")

//639.04 Base Impostos diferenciada
Local lBaseImp		:= F040BSIMP(2)
Local nPropPcc		:= 0
Local lTemMovCh		:= .F.
Local nPropPr		:= 0
Local lTpDesc		:= cPaisLoc == 'BRA' //Verifica campo TPDESC na tabela SE5 (<C>ondicional ou <I>ncondicional)
Local lDescFULL 	:= (nDescont > 0) .and. (nValor == 0) .and. (cTpDoc == "VL") //trato baixa 100% com desconto para gerar registro do tipo VL igual a E5_VALOR zerado!

//***Reestruturacao SE5***
Local oSubFK1
Local oSubFK3
Local oSubFK4
Local oSubFK5
Local oSubFK6
Local oSubFK7
Local oSubFKA
Local oSubFK9
Local oSubFKAux
Local nTxMoedAux	:= 0
Local nJurAux		:= 0
Local nMulAux		:= 0
Local nDesAux		:= 0
Local nValM2Aux		:= 0
Local nX			:= 0
Local cIdFK1		:= FWUUIDV4()
Local cChaveTit		:= ''
Local aImpostos		:= {}
Local aAreaAnt		:= {}
Local nTamHist 		:= TamSX3("FK5_HISTOR")[1]
Local oModelMov 	:= NIL	//FWLoadModel("FINM030") 	//Model de Movimento bancario
Local oSubFKAMV
Local oSubFK5MV
Local oSubFK9MV
Local lMovCh		:= FwIsInCallStack("FINA191")
Local cCamposE5M	:= ""
Local cCheque		:= IIf(!Empty(SEF->EF_NUM),SEF->EF_NUM,'')
Local cIdDoc		:= ''
Local cIdFk4		:= ''
Local cIdFk4IR		:= ''
Local lFin70		:= ( FwIsInCallStack("FINA070") .Or. FwIsInCallStack("FINA740") ) .And. !FwIsInCallStack("FINA200")
Local nRecSE5		:= 0
Local nTamArqCNAB	:= TamSx3("FK1_ARCNAB")[1]
Local lImpBxCr		:= GetNewPar( "MV_IMPBXCR", "1" ) == "2" 
Local lBruto		:= SuperGetMV("MV_BQ10925",,"2") == "1"

Local lFinm010	:= ExistBlock("FINM010")
//***Reestruturacao SE5***


PRIVATE lRaRtImp  	:= FRaRtImp()     //Define se ha retencao de impostos PCC/IRPJ no R.A
DEFAULT cRecPAg 		:= "R"
DEFAULT nSomaCheq 	:= 0
DEFAULT cProc 			:= 0 //Codigo do Processo Financeiro
DEFAULT cLoteFin := ""
DEFAULT cProc		:= ''
DEFAULT cChaveSEF	:= ''
DEFAULT cCamposE5	:= ''
DEFAULT nVA := 0			//Valores Acessorios
DEFAULT nValCalc := nValor
DEFAULT cFormPagto	:= ''
DEFAULT lMultNat := .F.
If lFin70
	DEFAULT cTpDesc := "C"
Endif

lTemMovCh	:= IIF( lFin70 .And. lFa070Tit, ((nValRec-nSomaCheq)==0 .And. SuperGetMv("MV_SLDBXCR",,"B") == "C"), .f. )

nVlRetPis	:= Iif(Type("nVlRetPis") != "N",0,nVlRetPis)
nVlRetCof	:= Iif(Type("nVlRetCof") != "N",0,nVlRetCof)
nVlRetCsl	:= Iif(Type("nVlRetCsl") != "N",0,nVlRetCsl)

nPis		:= If(Type("nPis"   ) != "N",0,nPis)
nCofins		:= If(Type("nCofins") != "N",0,nCofins)
nCsll	   	:= If(Type("nCsll"  ) != "N",0,nCsll)
nIrrf	   	:= If(Type("nIrrf"  ) != "N",0,nIrrf)
nOldIrrf 	:= If(Type("nOldIrrf" ) != "N",0,nOldIrrf)
nValRec	   	:= If(Type("nValRec") != "N",0,nValRec)
nTotAbat	:= If(Type("nTotAbat") != "N",0,nTotAbat)
cNumBor		:= If(Type("cNumBor") != "C",Space(6),cNumBor)

nPisCalc	:= Iif(Type("nPisCalc")  != "N",0,nPisCalc)
nCofCalc	:= Iif(Type("nCofCalc")  != "N",0,nCofCalc)
nCslcalc	:= Iif(Type("nCslcalc")  != "N",0,nCslcalc)
nPisBaseC	:= Iif(Type("nPisBaseC") != "N",0,nPisBaseC)
nCofBaseC	:= Iif(Type("nCofBaseC") != "N",0,nCofBaseC)
nCslBaseC	:= Iif(Type("nCslBaseC") != "N",0,nCslBaseC)
nIrfBaseC	:= Iif(Type("nIrfBaseC") != "N",0,nIrfBaseC)
nPisBaseR	:= Iif(Type("nPisBaseR") != "N",0,nPisBaseR)
nCofBaseR	:= Iif(Type("nCofBaseR") != "N",0,nCofBaseR)
nCslBaseR	:= Iif(Type("nCslBaseR") != "N",0,nCslBaseR)
nIrfBaseR	:= Iif(Type("nIrfBaseR") != "N",0,nIrfBaseR)
lAlterImp	:= Iif(Type("lAlterImp") != "L",.F.,lAlterImp)
nOldPis     := Iif(Type("nOldPis")  != "N",0,nOldPis)
nOldCofins	:= Iif(Type("nOldCofins")  != "N",0,nOldCofins)
nOldCsll	:= Iif(Type("nOldCsll")  != "N",0,nOldCsll)

nAcresc		:= Iif(Type("nAcresc")  != "N",0,nAcresc)
 
If Type("aDadosRet") != "A" .or. Empty(aDadosRet)
	aDadosRet := Array(7)
	AFill( aDadosRet, 0 ) 
Endif	        

If lPccBxCr .and. dDataBase >= dLastPcc
	nVlMinImp	:= 0
EndIf

//Verificar ou nao o limite de 5000 para Pis cofins Csll
// 1 = Verifica o valor minimo de retencao
// 2 = Nao verifica o valor minimo de retencao
If SE1->E1_APLVLMN == "2"
	lAplVlMin := .F.
Endif

nBaseRet := nValRec + nPis + nCofins + nCsll + nIrrf + nDescont + nTotAbat - nJuros - nVA - nMulta

//639.04 Base Impostos diferenciada
If lBaseImp .and. SE1->E1_BASEPIS > 0
	nPropPcc := nBaseRet/SE1->E1_VALOR
	nBaseRet	:= SE1->E1_BASEPIS * nPropPcc
Endif

If lFin70 .AND. cTpDoc <> "VL"
	If ( nValor == 0 .And. !( nTotAbat == nValTot ) ) .or. ( nValor == 0 .and. !( nDescont == nValTot ) )
		If (!lDescFULL .Or. nDescont == nValTot) .And. (TrazCodMot(cMotBx) $ "DAC" .And. cTpDoc != "BA")
			Return
		Endif
	EndIf
EndIf

dbSelectArea("SA6")
SA6->( dbSeek(xFilial("SA6")+cBanco+cAgencia+cConta) )
dbSelectArea("SE5")

cHistMov :=  Left(cHistMov, nTamHist)

If !(i == 0 .And. lMovCh)
	oSubFK1 := oModelBxR:GetModel('FK1DETAIL') //BAIXAS A RECEBER
	oSubFK3 := oModelBxR:GetModel('FK3DETAIL') //IMPOSTOS CALCULADOS
	oSubFK4 := oModelBxR:GetModel('FK4DETAIL') //IMPOSTOS RETIDOS
	oSubFK5 := oModelBxR:GetModel('FK5DETAIL') //MOVTO BANCARIO
	oSubFK6 := oModelBxR:GetModel('FK6DETAIL') //VALORES ACESSORIOS
	oSubFK7 := oModelBxR:GetModel('FK7DETAIL') //CONTROLE DOCTOS
	oSubFKA := oModelBxR:GetModel('FKADETAIL')
	oSubFK9 := oModelBxR:GetModel('FK9DETAIL')
EndIf

//Gravo aqui somente se o TipoDoc for igual a 'BA', 'VL' ou 'V2'
If i == 1 .Or. i == 2
	//Para movimentos de baixa e movimentos gerados em separado (localizações - movimentos N-N)
	//O número do processo deve ser o mesmo
	If cProc <> ""
		oModelBxR:SetValue( "MASTER", "IDPROC", cProc )
		oModelBxR:SetValue( "MASTER", "NOVOPROC", .F. ) //Informa que a inclusão não será feita com um novo número de processo
	Endif
	//Relacionamento FKA X FK1
	If !oSubFKA:IsEmpty()
		//Inclui a quantidade de linhas necessárias
		oSubFKA:AddLine()
		//Vai para linha criada
		oSubFKA:GoLine(oSubFKA:Length())
	EndIf

	oSubFKA:SetValue('FKA_IDORIG',cIdFK1)
	oSubFKA:SetValue('FKA_TABORI','FK1')

	If !Empty(cCamposE5)
		cCamposE5 += "|"
	Endif

	//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
	If Empty(cCamposE5) .or. substr(cCamposE5,len(cCamposE5),1) == "|"
	    cCamposE5 += "{"
	Else
		cCamposE5 += ","
	Endif
	//Gravacao dos campos que nao estao no de/para do model
	cCamposE5 += " {'E5_BANCO','" + cBanco + "'}"
	cCamposE5 += ",{'E5_AGENCIA','" + cAgencia + "'}"
	cCamposE5 += ",{'E5_CONTA','" + cConta + "'}"
	cCamposE5 += ",{'E5_FORMAPG','" + cFormPagto + "'}"	

	//Comeco a gravacao dos valores no submodel FK1
	oSubFK1:SetValue('FK1_DATA',dBaixa)
	oSubFK1:SetValue('FK1_ORIGEM',FunName())

	nTxMoedAux := IIf(Type("aTxMoedas") == "A" .And. cPaisLoc <> 'BRA',aTxMoedas[nMoedaBco][2],nTxMoeda)
	
	If cPaisLoc <> "BRA"
		If Empty(cBanco+cAgencia+cConta) .And. !Empty(SE1->E1_RECIBO)
		 	nMoedaBco := Max( SE1->E1_MOEDA, 1)
		Else
			nMoedaBco := Max( SA6->A6_MOEDA, 1)
		EndIf

		oSubFK1:SetValue('FK1_TXMOED',nTxMoedAux)
		oSubFK1:SetValue('FK1_VALOR',xMoeda(nValor,IIf(SE1->E1_MOEDA == nMoedaBco,SE1->E1_MOEDA,1),nMoedaBco,,,,nTxMoedAux))
		oSubFK1:SetValue('FK1_MOEDA',StrZero(nMoedaBco,2))

	Else
		nMoedaBco := Max( SA6->A6_MOEDA, 1)
		oSubFK1:SetValue('FK1_VALOR',nValor)
		oSubFK1:SetValue('FK1_MOEDA',StrZero(Max(nMoedaBco,1),2))		
	EndIf

	// Grava o valor de correção monetária no SE5 para ser visualizado na consulta
	If cPaisLoc == "MEX" .And. SEL->EL_MOEDA <> "1" .And. FunNAme() == "FINA087A"
		nTxCor:= Iif(SE1->E1_TXMOEDA > 0, SE1->E1_TXMOEDA, RecMoeda(SE1->E1_EMISSAO, SE1->E1_MOEDA))
		nValOrig:= xMoeda(SEL->EL_VALOR,Val(SEL->EL_MOEDA),1,,,nTxCor)
		nValAtu:= xMoeda(SEL->EL_VALOR,Val(SEL->EL_MOEDA),1,,,SE5->E5_TXMOEDA)
		cCamposE5 += ",{'E5_VLCORRE'," + Str(nValAtu - nValOrig) + "}"
	EndIf
	
	cCamposE5 += ",{'E5_TIPO'		,'" + SE1->E1_TIPO + "'}"
	cCamposE5 += ",{'E5_PREFIXO'	,'" + SE1->E1_PREFIXO + "'}"
	cCamposE5 += ",{'E5_NUMERO'		,'" + SE1->E1_NUM + "'}"
	cCamposE5 += ",{'E5_PARCELA'	,'" + SE1->E1_PARCELA + "'}"
	cCamposE5 += ",{'E5_CLIFOR'		,'" + SE1->E1_CLIENTE + "'}"
	cCamposE5 += ",{'E5_CLIENTE'	,'" + SE1->E1_CLIENTE + "'}"
	cCamposE5 += ",{'E5_LOJA'		,'" + SE1->E1_LOJA + "'}"                            
	cCamposE5 += ",{'E5_BENEF'		,'" + StrTran(SE1->E1_NOMCLI,"'","") + "'}"
	cCamposE5 += ",{'E5_MULTNAT'	,'" + If(lMultNat,"1","2") + "'}"
	cCamposE5 += ",{'E5_DTDIGIT'	,STOD('" +  DTOS(dDataBase) + "')}"
	
	oSubFK1:LoadValue('FK1_NATURE',SE1->E1_NATUREZ)
	oSubFK1:SetValue('FK1_RECPAG',cRecPag)	
	oSubFK1:SetValue('FK1_LA',Iif(lPadrao .And. lContabiliza,"S","N"))
	oSubFK1:SetValue('FK1_TPDOC',cTpDoc)
	oSubFK1:SetValue('FK1_HISTOR',cHistMov)
	oSubFK1:SetValue('FK1_LOTE',cLoteFin)
	oSubFK1:SetValue('FK1_MOTBX',TrazCodMot(cMotBx))
	oSubFK1:SetValue('FK1_SERREC',SE1->E1_SERREC)
	oSubFK1:SetValue('FK1_ORDREC',SE1->E1_RECIBO)
	oSubFK1:SetValue('FK1_FILORI',SE1->E1_FILORIG)
	oSubFK1:SetValue('FK1_CCUSTO',SE1->E1_CCUSTO)
	oSubFK1:SetValue('FK1_VENCTO',SE1->E1_VENCTO)
	oSubFK1:SetValue('FK1_MULNAT', If(lMultNat,"1","2"))	

	If lFin70  .And. lTpDesc
		cCamposE5 += ",{'E5_TPDESC','" + cTpDesc + "'}"
	Endif
	
	If SE1->E1_MOEDA > 1 .And. nValEstrang !=0 // somente para VL/BA
		nValM2Aux := nValEstrang
	Else
		nValM2Aux := Iif(SE1->E1_MOEDA <= 1,Round(xMoeda(nValor,nMoedaBco,SE1->E1_MOEDA,dbaixa,4,,SE5->E5_TXMOEDA),2),0)
	EndIf	
	
	oSubFK1:SetValue('FK1_VLMOE2',nValM2Aux)
	oSubFK1:SetValue('FK1_SEQ',cSequencia)
	
	If !(Empty(cNumBor)) // FINA200 - CNAB
		cCamposE5 += ",{'E5_DOCUMEN','" + cNumBor + "'}"
	EndIf

	//	Data de disponibilizacao -> considera dias de retencao
	nRetencao := SA6->A6_RETENCA
	dDataDisp := dBaixa
	
	If i == 1 .And. nCM <> 0
		cCamposE5 += ",{'E5_VLCORRE'," + Str(nCm) + "}"
	Endif
	
	If nRetencao > 0
		For nCont := 1 To nRetencao
			dDataDisp := DataValida(dDataDisp+1,.T.)
		Next nCont
	EndIf
	
	dDataAux := IIf(Empty(dDtCredito),dDataDisp,dDtCRedito)
	
	cCamposE5 += ",{'E5_DTDISPO',STOD('" + DTOS(dDataAux) + "') }"
	
	oSubFK1:SetValue('FK1_ARCNAB',Pad(cArqEnt,nTamArqCNAB))
	oSubFK1:SetValue('FK1_CNABOC',cOcorr)

	If cPaisLoc == "BRA" .And. SE1->E1_MOEDA > 1
		oSubFK1:SetValue('FK1_TXMOED',nTxMoeda)
	EndIf

	oSubFK1:SetValue('FK1_SITCOB',SE1->E1_SITUACA)

	//Dados da tabela auxiliar com o código do título a pagar
	cChaveTit := xFilial("SE1") + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" + SE1->E1_PARCELA + "|" + SE1->E1_TIPO + "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
	cIdDoc := FINGRVFK7("SE1", cChaveTit)
	
	oSubFK1:SetValue("FK1_IDDOC",cIdDoc)	

	// Grava valores quando o valor a receber for o mesmo que o do cheque, e a movimentação apenas quando o cheque for compensado
	If i == 2 .And. lTemMovCh
		If cPaisLoc == "BRA"
			cCamposE5 += ",{'E5_VLJUROS'," + Str(nJuros) + "}"
			cCamposE5 += ",{'E5_VLMULTA'," + Str(nMulta) + "}"
			cCamposE5 += ",{'E5_VLDESCO'," + Str(nDescont) + "}"
		EndIf
	EndIf	

	If i == 1
		If cPaisLoc == "BRA"
			nJurAux := nJuros
			nMulAux := nMulta
			nDesAux := nDescont
		Else
			nJurAux := Round(NoRound(xMoeda(nJuros,1,nMoedaBco,dBaixa,3,nTxMoedAux),3),2)
			nMulAux := Round(NoRound(xMoeda(nMulta,1,nMoedaBco,dBaixa,3,nTxMoedAux),3),2)
			nDesAux := Round(NoRound(xMoeda(nDescont,1,nMoedaBco,dBaixa,3,,nTxMoedAux),3),2)
		Endif

		cCamposE5 += ",{'E5_VLJUROS'," + Str(nJurAux) + "}"
		cCamposE5 += ",{'E5_VLMULTA'," + Str(nMulAux) + "}"
		cCamposE5 += ",{'E5_VLDESCO'," + Str(nDesAux) + "}"
		cCamposE5 += ",{'E5_VLACRES'," + Str(Round(NoRound(xMoeda(nAcresc,SE1->E1_MOEDA,1,dBaixa,3,SE1->E1_TXMOEDA),3),2)) +"}"
		cCamposE5 += ",{'E5_VLDECRE'," + Str(Round(NoRound(xMoeda(SE1->E1_SDDECRE,SE1->E1_MOEDA,1,dBaixa,3,SE1->E1_TXMOEDA),3),2)) +"}" 
	
		If ExistTemplate("GEMSE5Grv")
			ExecTemplate("GEMSE5Grv",.F.,.F.)
		EndIf
		
	    IF lRaRtImp .And. lFin70 .And. nTotAbat < (nTotAbImp-nTotAbLiq)
	    	nPropPr:= nTotAbat/(nTotAbImp-nTotAbLiq)
	    	cCamposE5 += ",{'E5_PRINSS'," + Str(SE1->E1_INSS * nPropPr) + "}"
	    	cCamposE5 += ",{'E5_PRISS'," + Str(SE1->E1_ISS * nPropPr) + "}"
		Endif
	
		//PCC BAIXA CR
		//GRAVACAO SFQ
		If lFa070Imp .and. lF070Imp2 .and. lImpBxCr
			If nOldIrrf == 0 .and. nIrrf > 0
				nIrfBaseC	:= nValor
				nIrfBaseR	:= nValor
			EndIf
			If nOldPis == 0 .and. nPis > 0
				nPisBaseC	:= nValor
				nPisBaseR	:= nValor
			EndIf
			If nOldCofins == 0 .and. nCofins > 0
				nCofBaseC	:= nValor
				nCofBaseR	:= nValor
			EndIf
			If nOldCsll == 0 .and. nCsll > 0
				nCslBaseC	:= nValor
				nCslBaseR	:= nValor
			EndIf
		EndIf
		If ( cPaisLoc == "BRA" .AND. lPCCBxCR ) .OR. ( FXMultSld() .AND. lPCCBxCR .AND. SA6->A6_MOEDA <= 1 )
			If !FwisInCallStack("Fa450CMP")			
				nValor -= (nPis + nCofins + nCsll)
			EndIf
			If lFa070Imp .and. lF070Imp2 .and. lImpBxCr .and. nOldIrrf == 0 .and. nIrrf > 0
				nValor -= nIrrf
			ElseIf (!lFa070Imp .and. !lF070Imp2) .and. lIrPjBxCr .and. nIrrf > 0 .and. Type('lF070Auto') == 'L' .And. lF070Auto
				nValor -= nIrrf
			EndIf
			oSubFK1:SetValue( 'FK1_VALOR', nValor )
	
			cCamposE5 += ",{'E5_VRETPIS'," + Str(nPis) + "}"
			cCamposE5 += ",{'E5_VRETCOF'," + Str(nCofins) + "}"
			cCamposE5 += ",{'E5_VRETCSL'," + Str(nCsll) + "}"
	
			//***Reestruturacao SE5***
			// Grava os valores agregados ao titulo no totalizador 
			//aImpostos[1] = codigo imposto
			//aImpostos[2] = imposto calculado
			//aImpostos[3] = natureza
			//aImpostos[4] = cIdFK4															
			//aImpostos[5] = imposto retido
			//aImpostos[6] = base calculado
			//aImpostos[7] = base retencao 
			If nIrrf > 0 .and. lIrPjBxCr
				nIrfCalc := SE1->E1_VRETIRF
				If nIrfBaseR == 0 .or. nIrfBaseC == 0
					nIrfBaseC := nIrfBaseR := SE1->E1_BASEIRF
				EndIf	
				aadd(aImpostos,{"IRF",nIrfCalc,&(SuperGetMV("MV_IRF")),"", nIrrf, nIrfBaseC, nIrfBaseR})
			Endif

			aadd(aImpostos,{"PIS", nPisCalc ,SuperGetMV("MV_PISNAT"),"", nPis    , nPisBaseC, nPisBaseR})
			aadd(aImpostos,{"COF", nCofCalc ,SuperGetMV("MV_COFINS"),"", nCofins , nCofBaseC, nCofBaseR})  
			aadd(aImpostos,{"CSL", nCslcalc ,SuperGetMV("MV_CSLL")  ,"", nCsll   , nCslBaseC, nCslBaseR})
			
			//Grava FK3 E/OU FK4
			For nX := 1 to Len(aImpostos)
				//Gravar FK4 se os valores de PCC forem maiores que zero
				If aImpostos[nX][2] > 0
                        
					cIdFK4 := ""
					If aImpostos[nX][5] > 0 //Houve retencao
						cIdFK4:= GetSx8Num('FK4', 'FK4_IDFK4')
						aImpostos[nX,4] := cIdFK4

						//Guardo o IDFK4 do IRF para usar posteriormente
						If aImpostos[nX,1] == "IRF"
							cIdFk4IR := cIdFK4
						Endif

					Endif
                        
					If !oSubFK3:IsEmpty()
						//Inclui a quantidade de linhas necessárias
						oSubFK3:AddLine()		
					
						//Vai para linha criada
						oSubFK3:GoLine( oSubFK3:Length() )	
					Endif	
		
					//---------------------------------------------
					// Grava Imposto calculado
					//---------------------------------------------
					oSubFK3:SetValue( "FK3_IDFK3" , GetSx8Num('FK3', 'FK3_IDFK3'))
					oSubFK3:SetValue( "FK3_DATA"  , dDataBase )
					oSubFK3:SetValue( "FK3_ORIGEM", FunName() )
					oSubFK3:SetValue( "FK3_IMPOS" , aImpostos[nX][1] )
					oSubFK3:SetValue( "FK3_RECPAG", "R" )
					oSubFK3:SetValue( "FK3_MOEDA" , "01" )
					oSubFK3:SetValue( "FK3_VALOR" , aImpostos[nX][2] )
					oSubFK3:SetValue( "FK3_NATURE", PadR(AllTrim(aImpostos[nX][3]),LEN(SED->ED_CODIGO)," ") )
					oSubFK3:SetValue( "FK3_FILORI", SE1->E1_FILORIG  )
					oSubFK3:SetValue( "FK3_BASIMP", aImpostos[nX][6] )
					oSubFK3:SetValue( "FK3_IDORIG", cIdFK1 )
					oSubFK3:SetValue( "FK3_TABORI", "FK1") 
					oSubFK3:SetValue( "FK3_IDRET" , aImpostos[nx,4] )       
                            
					//---------------------------------------------
					// Grava Imposto Retido
					//---------------------------------------------
					If aImpostos[nX][5] > 0   //Houve retencao
						If !oSubFK4:IsEmpty()
							//Inclui a quantidade de linhas necessárias
							oSubFK4:AddLine()		
						
							//Vai para linha criada
							oSubFK4:GoLine( oSubFK4:Length() )	
						Endif	
	
						oSubFK4:SetValue( "FK4_IDFK4" , aImpostos[nx,4])
						oSubFK4:SetValue( "FK4_DATA"  , dDataBase )
						oSubFK4:SetValue( "FK4_ORIGEM", FunName() )
						oSubFK4:SetValue( "FK4_IMPOS" , aImpostos[nx,1] )
						oSubFK4:SetValue( "FK4_RECPAG", "R" )
						oSubFK4:SetValue( "FK4_MOEDA" , "01" )
						oSubFK4:SetValue( "FK4_VALOR" , aImpostos[nX,5] )
						oSubFK4:SetValue( "FK4_NATURE", PadR(AllTrim(aImpostos[nX][3]),LEN(SED->ED_CODIGO)," ") )
						oSubFK4:SetValue( "FK4_FILORI", SE1->E1_FILORIG )
						oSubFK4:SetValue( "FK4_BASIMP", aImpostos[nX][7] )
					Endif					
				Endif
			Next nX

			Do Case
			Case cModRetPIS == "1"
				If	(aDadosRet[1] + nBaseRet > nVlMinImp .or. !lAplVlMin .OR. (nPis + nCofins + nCsll > 0 .and. lAlterImp)) .And. (nPis + nCofins + nCsll > 0)
					lRetParc := .T.
	
					nSavRec := SE5->( Recno() )
	
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If aDadosRet[1] > 0
						If Type("lAlterImp")!="L"
							lAlterImp := .F.
						EndIf
						aRecnos		:= aClone(Iif(lAlterImp .and. !lPccBxCr,aDadosRet[5],aDadosRet[6]))
						cPrefOri	:= SE1->E1_PREFIXO
						cNumOri		:= SE1->E1_NUM
						cParcOri	:= SE1->E1_PARCELA
						cTipoOri	:= SE1->E1_TIPO
						cCfOri		:= SE1->E1_CLIENTE
						cLojaOri	:= SE1->E1_LOJA
	
						For nLoop := 1 to Len( aRecnos )
	
							SE5->( dbGoto( aRecnos[ nLoop ] ) )
							If !Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)
								//Atualiza a informação de retencao de impostos em outro titulo									
								//Carrego o Model
								aAreaAnt := GetArea()
								oModelBxRA := FWLoadModel("FINM010")					
								oModelBxRA:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
								oModelBxRA:Activate()
								oModelBxRA:SetValue("MASTER","E5_GRV",.T.) //Habilita gravação SE5
								oSubFKAux := oModelBxRA:GetModel("FKADETAIL")
								oSubFKAux:SeekLine({{"FKA_IDORIG",SE5->E5_IDORIG}})
	
								//Atualizar o status de retencao de impostos          
								oSubFK3A := oModelBxRA:GetModel( "FK3DETAIL" )
								For nX := 1 to Len(aImpostos)
									If oSubFK3A:SeekLine({{"FK3_IMPOS",aImpostos[nX,1]}}) //Nome do imposto 
										If aImpostos[nX,1] != "IRF"
											oSubFK3A:SetValue("FK3_IDRET",aImpostos[nX,4]) //cIdFk4
										Endif											
									Endif
								Next nX
	
								cCamposE5A := "{{'E5_PRETPIS' , '2'}"
								cCamposE5A += ",{'E5_PRETCOF' , '2'}"
								cCamposE5A += ",{'E5_PRETCSL' , '2'}}"
	
								oModelBxRA:SetValue("MASTER","E5_CAMPOS",cCamposE5A)
								//Grava os dados
								If oModelBxRA:VldData()
								    oModelBxRA:CommitData()
								Else
									lRet := .F.
								    cLog := cValToChar(oModelBxRA:GetErrorMessage()[4]) + ' - '
								    cLog += cValToChar(oModelBxRA:GetErrorMessage()[5]) + ' - '
								    cLog += cValToChar(oModelBxRA:GetErrorMessage()[6])        	
									Help( ,,"M010VLDI1",,cLog, 1, 0 )
									Exit	             
								Endif
								oModelBxRA:DeActivate()
								oModelBxRA:Destroy()
								oModelBxRA:= Nil
								RestArea(aAreaAnt)
							EndIf
							
							If nSavRec <> aRecnos[ nLoop ]
								dbSelectArea("SFQ")
								RecLock("SFQ",.T.)
								SFQ->FQ_FILIAL  := xFilial("SFQ")
								SFQ->FQ_ENTORI  := "E1B"
								SFQ->FQ_PREFORI := cPrefOri
								SFQ->FQ_NUMORI  := cNumOri
								SFQ->FQ_PARCORI := cParcOri
								SFQ->FQ_TIPOORI := cTipoOri
								SFQ->FQ_CFORI   := cCfOri
								SFQ->FQ_LOJAORI := cLojaOri
								SFQ->FQ_SEQORI  := cSequencia
	
								SFQ->FQ_ENTDES  := "E1B"
								SFQ->FQ_PREFDES := SE5->E5_PREFIXO
								SFQ->FQ_NUMDES  := SE5->E5_NUMERO
								SFQ->FQ_PARCDES := SE5->E5_PARCELA
								SFQ->FQ_TIPODES := SE5->E5_TIPO
								SFQ->FQ_CFDES   := SE5->E5_CLIFOR
								SFQ->FQ_LOJADES := SE5->E5_LOJA
								SFQ->FQ_SEQDES  := SE5->E5_SEQ
	
								//Grava a filial de destino caso o campo exista
								SFQ->FQ_FILDES := SE5->E5_FILIAL
	
								SFQ->(MsUnlock())
							Endif
						Next nLoop
					EndIf
	
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Retorna do ponteiro do SE1 para a parcela         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					SE5->( MsGoto( nSavRec ) )
					
				Else
					If nVlRetPis + nVlRetCof + nVlRetCsl > 0
						//Atualiza a informação de retencao de impostos no titulo que está sendo baixado	
						//Carrego o Model
						cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nVlRetPis)+"}"
						cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nVlRetCof)+"}"
						cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nVlRetCsl)+"}"
						cCamposE5 += ",{'E5_PRETPIS' , '1'}"
						cCamposE5 += ",{'E5_PRETCOF' , '1'}"
						cCamposE5 += ",{'E5_PRETCSL' , '1'}"
	
					EndIf
					lRetParc := .F.
				EndIf
	
			Case cModRetPIS == "2"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Efetua a retencao                                                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nSavRec := SE5->( Recno() )
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Exclui a Marca de "pendente recolhimento" dos demais registros   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If aDadosRet[1] > 0
					aRecnos := aClone( Iif(ValType(lAlterImp)!="U" .And. lAlterImp .and. !lPccBxCr,aDadosRet[ 5 ],aDadosRet[ 6 ]) )
	
					cPrefOri  := SE5->E5_PREFIXO
					cNumOri   := SE5->E5_NUMERO
					cParcOri  := SE5->E5_PARCELA
					cTipoOri  := SE5->E5_TIPO
					cCfOri    := SE5->E5_CLIFOR
					cLojaOri  := SE5->E5_LOJA
	
				  	For nLoop := 1 to Len( aRecnos )
	
						SE5->( dbGoto( aRecnos[ nLoop ] ) )
						
						If !Empty(SE5->E5_PRETPIS) .And. !Empty(SE5->E5_PRETCOF) .And. !Empty(SE5->E5_PRETCSL)
							//Atualiza a informação de retencao de impostos em outro titulo									
							//Carrego o Model
							aAreaAnt := GetArea()					
							oModelBxRA := FWLoadModel("FINM010")
							oModelBxRA:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
							oModelBxRA:Activate()
							oModelBxRA:SetValue("MASTER","E5_GRV",.T.) //Habilita gravação SE5
							oSubFKAux := oModelBxRA:GetModel("FKADETAIL")
							oSubFKAux:SeekLine({{"FKA_IDORIG",SE5->E5_IDORIG}})

							//Atualizar o status de retencao de impostos          
							oSubFK3A:= oModelBxRA:GetModel( "FK3DETAIL" )
							For nX := 1 to Len(aImpostos)
								If oSubFK3A:SeekLine({{"FK3_IMPOS",aImpostos[nX,1]}}) //Nome do imposto 
									If aImpostos[nX,1] != "IRF"
										oSubFK3A:SetValue("FK3_IDRET",aImpostos[nX,4]) //cIdFk4
									Endif											
								Endif
							Next nX

							cCamposE5A := "{{'E5_PRETPIS' , '2'}"
							cCamposE5A += ",{'E5_PRETCOF' , '2'}"
							cCamposE5A += ",{'E5_PRETCSL' , '2'}}"

							oModelBxRA:SetValue("MASTER","E5_CAMPOS",cCamposE5A)
							//Grava os dados
							If oModelBxRA:VldData()
							    oModelBxRA:CommitData()
							Else
								lRet := .F.
							    cLog := cValToChar(oModelBxRA:GetErrorMessage()[4]) + ' - '
							    cLog += cValToChar(oModelBxRA:GetErrorMessage()[5]) + ' - '
							    cLog += cValToChar(oModelBxRA:GetErrorMessage()[6])        	
								Help( ,,"M010VLDI1",,cLog, 1, 0 )
								Exit	             
							Endif
							oModelBxRA:DeActivate()
							oModelBxRA:Destroy()
							oModelBxRA:= Nil
							RestArea(aAreaAnt)	
						EndIf
	
						If nSavRec <> aRecnos[ nLoop ]
							dbSelectArea("SFQ")
							RecLock("SFQ",.T.)
							SFQ->FQ_FILIAL  := xFilial("SFQ")
							SFQ->FQ_ENTORI  := "E1B"
							SFQ->FQ_PREFORI := cPrefOri
							SFQ->FQ_NUMORI  := cNumOri
							SFQ->FQ_PARCORI := cParcOri
							SFQ->FQ_TIPOORI := cTipoOri
							SFQ->FQ_CFORI   := cCfOri
							SFQ->FQ_LOJAORI := cLojaOri
							SFQ->FQ_SEQORI  := cSequencia
	
							SFQ->FQ_ENTDES  := "E1B"
							SFQ->FQ_PREFDES := SE5->E5_PREFIXO
							SFQ->FQ_NUMDES  := SE5->E5_NUMERO
							SFQ->FQ_PARCDES := SE5->E5_PARCELA
							SFQ->FQ_TIPODES := SE5->E5_TIPO
							SFQ->FQ_CFDES   := SE5->E5_CLIFOR
							SFQ->FQ_LOJADES := SE5->E5_LOJA
							SFQ->FQ_SEQDES  := SE5->E5_SEQ
	
							//Grava a filial de destino caso o campo exista
							SFQ->FQ_FILDES := SE5->E5_FILIAL
							SFQ->(MsUnlock())
						Endif
					Next nLoop
	
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Retorna do ponteiro do SE1 para a parcela         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SE5->( MsGoto( nSavRec ) )
				Reclock( "SE1", .F. )
				lRetParc := .T.
			Case cModRetPIS == "3"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava a Marca de "pendente recolhimento" dos demais registros    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nVlRetPis + nVlRetCof + nVlRetCsl > 0
					//Atualiza a informação de retencao de impostos no titulo que está sendo baixado	
					//Carrego o Model
					cCamposE5 += ",{'E5_VRETPIS' , "+cValToChar(nVlRetPis)+"}"																		
					cCamposE5 += ",{'E5_VRETCOF' , "+cValToChar(nVlRetCof)+"}"
					cCamposE5 += ",{'E5_VRETCSL' , "+cValToChar(nVlRetCsl)+"}"
					cCamposE5 += ",{'E5_PRETPIS' , '1'}"
					cCamposE5 += ",{'E5_PRETCOF' , '1'}"
					cCamposE5 += ",{'E5_PRETCSL' , '1'}"
				EndIf
				lRetParc := .F.
			EndCase
		EndIf
		If cTpDoc $ 'VL|V2'
	
			//Relacionamento FKA X FK5
			If !oSubFKA:IsEmpty()
				//Inclui a quantidade de linhas necessárias
				oSubFKA:AddLine()
				//Vai para linha criada
				oSubFKA:GoLine(oSubFKA:Length())
			EndIf
	
			oSubFKA:SetValue('FKA_IDORIG',FWUUIDV4())
			oSubFKA:SetValue('FKA_TABORI','FK5')
			
			oSubFK5:SetValue( "FK5_RECPAG" , cRecPag )
			oSubFK5:SetValue( "FK5_HISTOR" , cHistMov )		
			oSubFK5:SetValue( "FK5_DATA"   , dBaixa )
			oSubFK5:SetValue( "FK5_DTDISP" , dDataAux ) 
			oSubFK5:LoadValue( "FK5_NATURE" , SE1->E1_NATUREZ )	
			oSubFK5:SetValue( "FK5_BANCO"  , cBanco )
			oSubFK5:SetValue( "FK5_AGENCI" , cAgencia )
			oSubFK5:SetValue( "FK5_CONTA"  , cConta )
			oSubFK5:SetValue( "FK5_SEQ"    , cSequencia )	
			oSubFK5:SetValue( "FK5_MOEDA"  , StrZero(Max(nMoedaBco,1),2) )
			oSubFK5:SetValue( "FK5_ORIGEM" , FunName() )
			oSubFK5:SetValue( "FK5_TPDOC"  , cTpDoc )		
			oSubFK5:SetValue( "FK5_CCUSTO" , SE1->E1_CCUSTO )
			oSubFK5:SetValue( "FK5_DOC"    , SE1->E1_NUMBOR )	
			oSubFK5:SetValue( "FK5_FILORI" , SE1->E1_FILORIG )		
	
			If ( cPaisLoc <> "BRA" )
				oSubFK5:SetValue( "FK5_VALOR" , xMoeda(nValor,IIf(SE1->E1_MOEDA == nMoedaBco,SE1->E1_MOEDA,1),nMoedaBco,,,,nTxMoedAux) )
				oSubFK5:SetValue( "FK5_VLMOE2", nValM2Aux )
				oSubFK5:SetValue( "FK5_TXMOED", nTxMoedAux )
				oSubFK5:SetValue( "FK5_MOEDA" , StrZero(nMoedaBco,2) )
			Else
				oSubFK5:SetValue( "FK5_VALOR" , nValor )
				oSubFK5:SetValue( "FK5_MOEDA" , StrZero(nMoedaBco,2) )
				oSubFK5:SetValue( "FK5_VLMOE2" , nValM2Aux )									
	
				If SE1->E1_MOEDA > 1
					oSubFK5:SetValue( "FK5_TXMOED", nTxMoedAux )						
				Endif
			EndIf
	
			// Para baixas STR ou CIP eu ignoro os dias de rentencao, ja que sao on-line
			If lSpbInUse
				oSubFK5:SetValue( "FK5_MODSPB" , cModSpb )
			
				If cModSpb $ "1#2"
					dDataDisp := dBaixa
				Endif
			Endif
	  
			oSubFK5:SetValue( "FK5_LA" , Iif(lPadrao.and.lContabiliza,"S","N") )
	
			If !Empty(cFormPagto)
				oSubFK9:SetValue('FK9_FORMPG',cFormPagto)
			EndIf

		EndIf		
	EndIf
ElseIf i <> 0 //Gravo os valore acessorios ('D2', 'DC', 'J2', 'JR', 'M2', 'MT', 'C2', 'CM' ou 'TL')
		
		If lFinm010
			cCamposE5 += "}"
			oModelBxR:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
		Endif
	
	If	oSubFKA:SeekLine({{'FKA_TABORI',"FK1"}})

		//-----------------------------------------------------------
		//Valores Acessorios.
		//-----------------------------------------------------------
		If cTpDoc == "VA" 
			//Grava Novos Valores Acessorios (FKD)
			cIdDoc := oSubFK1:GetValue("FK1_IDDOC")
			FSetFK6FKD( oSubFK6, cIdDoc, cIdFK1, "R" )
		Else
			//Grava Valores Acessorios (juros, multas, descontos etc)
			If !oSubFK6:IsEmpty()
				//Inclui a quantidade de linhas necessárias
				oSubFK6:AddLine()		
				//Vai para linha criada
				oSubFK6:GoLine( oSubFK6:Length() )	
			Endif	
			oSubFK6:SetValue("FK6_VALMOV",nValor)
			oSubFK6:SetValue("FK6_VALCAL",nValCalc)
			oSubFK6:SetValue("FK6_TPDOC",cTpDoc)
			oSubFK6:SetValue("FK6_RECPAG","R")
			oSubFK6:SetValue("FK6_IDORIG",cIdFK1)
			oSubFK6:SetValue("FK6_TABORI","FK1")	
			oSubFK6:SetValue("FK6_HISTOR",cHistMov)		
		Endif
	EndIf
	
	If lFinm010
		cCamposE5 := oModelBxR:GetModel("MASTER"):GetValue( "E5_CAMPOS" )
	Endif
	
EndIf

If i == 4
	cCamposE5 += ",{'E5_IDENTEE' ,'" + SE1->E1_IDENTEE + "'}" 
Endif

//Executo o movimento vindo do cheque
If i == 0 .And. lMovCh
	If cTpdoc $ "CH"	
		//Model de Movimento bancario
		oModelMov 	:= FWLoadModel("FINM030")
		oModelMov:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
		oModelMov:Activate()
		oSubFK5MV  := oModelMov:GetModel("FK5DETAIL")
		oSubFKAMV  := oModelMov:GetModel("FKADETAIL" )
		oSubFK9MV  := oModelMov:GetModel("FK9DETAIL" )
	
		// Inclui registro no SE5 para a geracao do cheque
		cCamposE5M += "{ {'E5_DTDIGIT',dDataBase     }"
		// Grava o valor de correção monetária no SE5 para ser visualizado na consulta
		If cPaisLoc == "MEX" .And. SEL->EL_MOEDA <> "1" .And. FunNAme() == "FINA087A" 
			nTxCor:= Iif(SE1->E1_TXMOEDA > 0, SE1->E1_TXMOEDA, RecMoeda(SE1->E1_EMISSAO, SE1->E1_MOEDA))
			nValOrig:= xMoeda(SEL->EL_VALOR,Val(SEL->EL_MOEDA),1,,,nTxCor)       
			nValAtu:= xMoeda(SEL->EL_VALOR,Val(SEL->EL_MOEDA),1,,,SE5->E5_TXMOEDA)
			cCamposE5M += " ,{'E5_VLCORRE'," + Str(nValAtu - nValOrig) + "}"
		EndIf
		cCamposE5M += " ,{'E5_ARQNAB'	,'" + cArqEnt +"' }"
		cCamposE5M += " ,{'E5_CNABOC'	,'" + cOcorr +"' }"
		cCamposE5M += " ,{'E5_BENEF'	,'" + StrTran(SE1->E1_NOMCLI,"'","") + "'}"
		cCamposE5M += " ,{'E5_TIPO'		, SE1->E1_TIPO}"
		cCamposE5M += " ,{'E5_LOTE'		,'" + cLoteFin + "'}"
		cCamposE5M += " ,{'E5_MOTBX'	,'" + TrazCodMot( cMotBx ) + "'}"
		cCamposE5M += " ,{'E5_SERREC'	, SE1->E1_SERREC}"
		cCamposE5M += " ,{'E5_ORDREC'	, SE1->E1_RECIBO}"
		cCamposE5M += " ,{'E5_SITCOB'	, SE1->E1_SITUACA}"
		cCamposE5M += " ,{'E5_PREFIXO'	, SE1->E1_PREFIXO}"	
		cCamposE5M += " ,{'E5_NUMERO'	, SE1->E1_NUM}"
		cCamposE5M += " ,{'E5_PARCELA'	, SE1->E1_PARCELA}"
		cCamposE5M += " ,{'E5_TIPO'		, SE1->E1_TIPO}"
		cCamposE5M += " ,{'E5_CLIFOR'	, SE1->E1_CLIENTE}"
		cCamposE5M += " ,{'E5_CLIENTE'	, SE1->E1_CLIENTE}"
		cCamposE5M += " ,{'E5_LOJA'		, SE1->E1_LOJA} }"
	
		oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5M )
		oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
		oModelMov:SetValue( "MASTER", "NOVOPROC", .T. ) //Novo processo
	
		//Dados do movimento bancario do Cheque
		If !oSubFKAMV:IsEmpty()
			//Inclui a quantidade de linhas necessárias
			oSubFKAMV:AddLine()		
			//Vai para linha criada
			oSubFKAMV:GoLine( oSubFKAMV:Length() )	
		Endif	
		
		cHistMov := Left(cHistMov, nTamHist)
		
		oSubFKAMV:SetValue( 'FKA_IDORIG', FWUUIDV4() ) 
		oSubFKAMV:SetValue( 'FKA_TABORI', 'FK5' )				
	
		oSubFK5MV:SetValue( "FK5_RECPAG" , "R" )
		oSubFK5MV:SetValue( "FK5_HISTOR" , cHistMov )		
		oSubFK5MV:SetValue( "FK5_DATA"   , dBaixa )
		oSubFK5MV:SetValue( "FK5_NATURE" , SE1->E1_NATUREZ )	
		oSubFK5MV:SetValue( "FK5_BANCO"  , cBanco )
		oSubFK5MV:SetValue( "FK5_AGENCI" , cAgencia )
		oSubFK5MV:SetValue( "FK5_CONTA"  , cConta )
		oSubFK5MV:SetValue( "FK5_NUMCH"  , cCheque )
		oSubFK5MV:SetValue( "FK5_SEQ"    , cSequencia )
	
		If ( cPaisLoc <> "BRA" )        
			If Empty(cBanco+cAgencia+cConta) .And.  !Empty(SE1->E1_RECIBO)
			 	nMoedaBco := Max( SE1->E1_MOEDA, 1)
			Else
				nMoedaBco := Max( SA6->A6_MOEDA, 1)
			EndIf
	 
			If Type("aTxMoedas") == "A"
		   		oSubFK5MV:SetValue( "FK5_TXMOED"	, aTxMoedas[nMoedaBco][2] )	
		 	Else
		   		oSubFK5MV:SetValue( "FK5_TXMOED"	, nTxMoeda )
		 	EndIf
	
			oSubFK5MV:SetValue( "FK5_VALOR"	, xMoeda( nValor, 1, nMoedaBco,,,,SE5->E5_TXMOEDA ) )
			oSubFK5MV:SetValue( "FK5_MOEDA"  , StrZero( nMoedaBco ,2) )
		Else
			If SE1->E1_MOEDA > 1
				oSubFK5MV:SetValue( "FK5_TXMOED"	, nTxMoeda )
			EndIf
	
			nMoedaBco := Max( SA6->A6_MOEDA, 1)
			oSubFK5MV:SetValue( "FK5_VALOR"	, nValor )
			oSubFK5MV:SetValue( "FK5_MOEDA"  , StrZero( Max( nMoedaBco , 1), 2 ) )
		EndIf		
	
		oSubFK5MV:SetValue( "FK5_VLMOE2" , Iif(SE1->E1_MOEDA <= 1,Round(xMoeda( nValor, nMoedaBco, SE1->E1_MOEDA,dbaixa,4,,SE5->E5_TXMOEDA ),2),0) )
		oSubFK5MV:SetValue( "FK5_ORIGEM" , FunName() )
		oSubFK5MV:SetValue( "FK5_TPDOC"  , cTpDoc )		
		oSubFK5MV:SetValue( "FK5_CCUSTO" , SE1->E1_CCUSTO )
		oSubFK5MV:SetValue( "FK5_FILORI" , SE1->E1_FILORIG )               				
		oSubFK5MV:SetValue( "FK5_LA"     , If( lPadrao .And. lContabiliza,"S","N") )
	
		nRetencao	:= SA6->A6_RETENCA
		dDataDisp	:= SE5->E5_DATA
	
		If nRetencao > 0
			For nCont := 1 To nRetencao
				dDataDisp := DataValida(dDataDisp+1,.T.)
			Next nCont
		EndIf
		
		If lSpbInUse
			oSubFK5MV:SetValue( "FK5_MODSPB" , cModSpb )
			If cModSpb $ "1#2"
				dDataDisp := dBaixa
			Endif
		Endif
	
		oSubFK5MV:SetValue( "FK5_DTDISP" , IIf(Empty(dDtCredito),dDataDisp,dDtCRedito) )
	
		//Dados do Cheque
		If !oSubFKAMV:IsEmpty()
			//Inclui a quantidade de linhas necessárias
			oSubFKAMV:AddLine()		
			//Vai para linha criada
			oSubFKAMV:GoLine( oSubFKAMV:Length() )	
		Endif	
		oSubFKAMV:SetValue( 'FKA_IDORIG', cChaveSEF )			
		oSubFKAMV:SetValue( 'FKA_TABORI', 'SEF' )		

		If !Empty(cFormPagto)
			oSubFK9MV:SetValue('FK9_FORMPG',cFormPagto)
		EndIf
	
		//Grava os dados
		If oModelMov:VldData()
			oModelMov:CommitData()          
			nRecSE5 := oModelMov:GetValue("MASTER","E5_RECNO")
			SE5->(dbGoTo(nRecSE5))
		Else
			lRet := .F.
		    cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
		    cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
		    cLog += cValToChar(oModelMov:GetErrorMessage()[6])        	
		    
		    Help( ,,"GRVSE501",,cLog, 1, 0 )	             
		Endif	
		oModelMov:DeActivate()
		oModelMov:Destroy()
		oModelMov:= Nil	
	Else
		cHistMov := Left(cHistMov, nTamHist)
		oModelMov 	:= FWLoadModel("FINM030")
		oModelMov:SetOperation( MODEL_OPERATION_UPDATE ) //Altera
		oModelMov:Activate()
		
		oSubFKAMV := oModelMov:GetModel( "FKADETAIL" )
		
		oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Informa se vai gravar SE5 ou não
		//E5_OPERACAO 1 = Altera E5_SITUACA da SE5 para 'C' e gera estorno na FK5
		//E5_OPERACAO 2 = Grava E5 com E5_TIPODOC = 'ES' e gera estorno na FK5
		//E5_OPERACAO 3 = Deleta da SE5 e gera estorno na FK5
		oModelMov:SetValue( "MASTER", "E5_OPERACAO", 2 )
		oModelMov:SetValue( "MASTER", "HISTMOV", cHistMov) 					
		//Posiciona a FKA com base no IDORIG da SE5 posicionada
		If oSubFKAMV:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
							  		
			If oModelMov:VldData()
				oModelMov:CommitData()
			Else
				lRet := .F.
				cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[6])        	
					    
				Help( ,,"M030VALID",,cLog, 1, 0 )
			Endif
		Endif								
		oModelMov:DeActivate()
		oModelMov:Destroy()
		oModelMov:= Nil
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PTO DE ENTRADA F70E5ADT										 ³
//³ Tratamento complementar da baixa de adiantamento			 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
IF lF70E5ADT
	ExecBlock("F70E5ADT",.f.,.f.)
Endif

If GetNewPar("MV_FATDIST","N") == "S" // Apenas quando utilizado pelo modulo de Distribuicao
	DSe5Fi070()
EndIf

Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070ADIANT

Processa baixa de adiantamento (RA).
Arquivo anterior: FINXATU.PRX

@Author	Vinicius S. Barreira
@since	26/10/1994
/*/
//-----------------------------------------------------------------------------------------------------
Function fa070Adiant( lPadrao, lContabiliza, lGerChqAdt, aBaixas, dDtCredito , nTxMoeda, lMultNat )
Local nTamSeq		:= TamSX3("E5_SEQ")[1]
Local cSequencia 	:= Replicate("0",nTamSeq)
Local nRetencao		:= 0
Local dDataDisp		:= Ctod("//")
Local nCont			:= 0
Local aTipoDoc 		:= {}
Local i 			:= 0
Local lSpbInUse 	:= SpbInUse()
Local nMoedaBco 	:= Max(MoedaBco(cBanco,cAgencia,cConta),1)
Local nMoedaTit 	:= SE1->E1_MOEDA
Local nTxMdTit  	:= If( cPaisLoc<>"BRA", aTxMoedas[Max(SE1->E1_MOEDA	,1)][2]	, 0 )
Local nTxMdBco  	:= If( cPaisLoc<>"BRA", aTxMoedas[Max(nMoedaBco		,1)][2]	, 0 )
Local nRecBx		:= 0
//Reestrutura das tabelas do processo de movimento bancário
Local oModelBxR		:= NIL //FWLoadModel("FINM010") //Model de baixas a receber
Local oSubFK1		:= Nil //BAIXAS A RECEBER
Local oSubFK5		:= Nil //MOVTO BANCARIO
Local oSubFK6		:= Nil //Valores complementares
Local cLog 			:= ""
Local cChaveFK7		:= ""
Local cCamposE5		:= ""
Local lRet 			:= .T.
Local oSubFKA		:= Nil //Baixas a receber para atualização de retenção
//Dados da tabela auxiliar com o código do título a receber (SE1)
Local cChaveTit		:= 	xFilial("SE1") + "|" + SE1->E1_PREFIXO + "|" + SE1->E1_NUM + "|" +	SE1->E1_PARCELA + "|" +;
							SE1->E1_TIPO	+ "|" + SE1->E1_CLIENTE + "|" + SE1->E1_LOJA
Local cFilSE5		:= FWxFilial('SE5')
Local cIdFK1		:= ''
Local cIdFK5		:= ''
Local cTpDoc 		:= ""
Local cOrigem 		:= ""
Local lMovBcoBx 	:= MovBcoBx( cMotBx, .T. )
Local cChaveCH		:= ""
Local aRecsSe5 		:= {}
Local nI			:= 0
Local nVlAcres		:= 0
Local nVlDecre		:= 0

DEFAULT lGerChqAdt 	:= .F.
DEFAULT aBaixas 	:= {}
DEFAULT dDtCredito	:= CtoD("")
DEFAULT lMultNat 	:= .F.

//Lipando o array aRecSe5 para conter somente o RECNO desta baixa.
FIM010CLRE5()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Localiza a sequencia da baixa ( CP,BA,VL,V2,LJ )				  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aTipoDoc := {"CP","BA","VL","V2"}
SE5->(dbSetOrder(2))
FOR I := 1 to Len(aTipoDoc)
	SE5->(dbSeek(xFilial("SE5") + aTipoDoc[i] + SE1->E1_PREFIXO + SE1->E1_NUM + ;
	SE1->E1_PARCELA + SE1->E1_TIPO ))
	While !SE5->(Eof()).AND. SE5->E5_FILIAL  == xFilial("SE5") .AND. SE5->E5_TIPODOC == aTipoDoc[i] ;
	.AND. SE5->E5_PREFIXO == SE1->E1_PREFIXO .AND. SE5->E5_NUMERO  == SE1->E1_NUM ;
	.AND. SE5->E5_PARCELA == SE1->E1_PARCELA .AND. SE5->E5_TIPO == SE1->E1_TIPO
			
		If PadL(AllTrim(cSequencia),nTamSeq,"0") < PadL(AllTrim(SE5->E5_SEQ),nTamSeq,"0")
			cSequencia := SE5->E5_SEQ
		Endif
		
		SE5->(dbSkip())
	EndDo
Next I
If Len(AllTrim(cSequencia)) < nTamSeq
	cSequencia := PadL(Alltrim(cSequencia),nTamSeq,"0")
Endif
cSequencia := Soma1(cSequencia,nTamSeq)
SE5->(dbSetOrder(1))

//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
If !Empty(cCamposE5)
    cCamposE5 += "|"
Endif
cCamposE5 += " { "
cCamposE5 += "{'E5_FILIAL'		,'" + cFilSE5 + "'}"
cCamposE5 += ",{'E5_PREFIXO'	,'" +  SE1->E1_PREFIXO+ "'}"
cCamposE5 += ",{'E5_NUMERO'		,'" +  SE1->E1_NUM + "'}"
cCamposE5 += ",{'E5_PARCELA'	,'" +  SE1->E1_PARCELA + "'}"
cCamposE5 += ",{'E5_CLIENTE'	,'" +  SE1->E1_CLIENTE + "'}"
cCamposE5 += ",{'E5_CLIFOR'		,'" +  SE1->E1_CLIENTE + "'}"
cCamposE5 += ",{'E5_LOJA'		,'" +  SE1->E1_LOJA + "'}"
cCamposE5 += ",{'E5_BENEF'		,'" +  StrTran(SE1->E1_NOMCLI,"'","") + "'}"
cCamposE5 += ",{'E5_TIPO'		,'" +  SE1->E1_TIPO + "'}"
cCamposE5 += ",{'E5_DTDIGIT'	, STOD('" + DTOS(dDataBase) + "')}"
cCamposE5 += ",{'E5_BANCO'		,'" +  cBanco + "'}"
cCamposE5 += ",{'E5_AGENCIA'	,'" + cAgencia + "'}"
cCamposE5 += ",{'E5_CONTA'		,'" +  cConta + "'}"
cCamposE5 += ",{'E5_DTDISPO'	, STOD('" + DTOS( Iif( Empty(dDtCredito), dBaixa, dDtCRedito ) ) + "')}"
cCamposE5 += ",{'E5_MULTNAT'	,'" + If(lMultNat,"1","2") + "'}"

If lSpbInUse
	cCamposE5 += ",{'E5_MODSPB'		, '1'}"
EndIf
cOrigem := FunName()

//Carrego model de Bx a Receber
oModelBxR := FWLoadModel("FINM010")
oModelBxR:SetOperation( MODEL_OPERATION_INSERT ) //Inclusao
oModelBxR:Activate()
oModelBxR:SetValue( "MASTER", "E5_GRV", .T. ) //habilita gravação de SE5
oModelBxR:SetValue( "MASTER", "NOVOPROC", .T. ) //Novo processo

oSubFK1 := oModelBxR:GetModel("FK1DETAIL")
oSubFK5 := oModelBxR:GetModel("FK5DETAIL")
oSubFK6 := oModelBxR:GetModel("FK6DETAIL")	
oSubFKA := oModelBxR:GetModel("FKADETAIL")

cChaveFK7 := FINGRVFK7("SE1", cChaveTit)

//Baixa Principal
If !oSubFKA:IsEmpty()
	oSubFKA:AddLine()
EndIf

cIdFK1 := FWUUIDV4()
oSubFKA:SetValue( "FKA_IDORIG"	, cIdFK1 )
oSubFKA:SetValue( "FKA_TABORI"	, 'FK1' )

If !oSubFK1:IsEmpty()
	oSubFK1:AddLine()
EndIf

If SE1->E1_TIPO $ MVRECANT .AND. cOrigem == "FINA630"
	cTpDoc := "VL"
Else
	cTpDoc := Iif( (lMovBcoBx .OR. SE1->E1_TIPO $ MVRECANT) .AND. !lGerChqAdt, "VL", "BA" ) 
EndIf

//Gera movimentação bancária a pagar - baixa do adiantamento
oSubFK1:SetValue( "FK1_DATA"	, dBaixa )		
oSubFK1:SetValue( "FK1_NATURE"	, SE1->E1_NATUREZ )
oSubFK1:SetValue( "FK1_RECPAG"	, "P" )
oSubFK1:SetValue( "FK1_HISTOR"	, cHist070 )
oSubFK1:SetValue( "FK1_MOTBX"	, TrazCodMot( cMotBx ) )
oSubFK1:SetValue( "FK1_ORIGEM"	, cOrigem )
oSubFK1:SetValue( "FK1_SEQ"		, cSequencia )
oSubFK1:SetValue( "FK1_DOC"		, SE1->E1_NUMBOR )
oSubFK1:SetValue( "FK1_IDDOC"	, cChaveFK7 )
oSubFK1:SetValue( "FK1_TPDOC"	, cTpDoc )
oSubFK1:SetValue( "FK1_CCUSTO"	, SE1->E1_CCUSTO )	
oSubFK1:SetValue( "FK1_FILORI"	, SE1->E1_FILORIG )
oSubFK1:SetValue( "FK1_VALOR"	, nValRec )
oSubFK1:SetValue( "FK1_MOEDA"	, StrZero(nMoedaBco,2) )
oSubFK1:SetValue( "FK1_LA"	   	, Iif( lPadrao .AND. lContabiliza, "S", "N" ) )
oSubFK1:SetValue( "FK1_LOTE"   	, cLoteFin )
oSubFK1:SetValue('FK1_MULNAT', If(lMultNat,"1","2"))	

If ( cPaisLoc<>"BRA" )
 	If AllTrim(Upper(SE1->E1_ORIGEM)) <> "FINA074"
    	If nValEstrang != 0
			oSubFK1:SetValue( "FK1_VLMOE2"	, nValEstrang )
		Else
			oSubFK1:SetValue( "FK1_VLMOE2"	, nValRec )
		Endif
	Else
		oSubFK1:SetValue( "FK1_VLMOE2"	, nValRec)
	EndIf
	oSubFK1:SetValue( "FK1_TXMOED"	, Max(nTxMdTit,nTxMdBco) )
Else
	If SE1->E1_MOEDA > 1 .And. nValEstrang != 0
		oSubFK1:SetValue( "FK1_VLMOE2"	, nValEstrang )
		oSubFK1:SetValue( "FK1_TXMOED"	, nTxMoeda )
	Else
		oSubFK1:SetValue( "FK1_VLMOE2"	, xMoeda(nValRec,1,SE1->E1_MOEDA) )
	EndIf
EndIf

If nJuros <> 0
	//Adicionando valores acessórios (Juros)
	If !oSubFK6:IsEmpty()
		oSubFK6:AddLine()
	EndIf
	oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
	oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
	oSubFK6:SetValue( 'FK6_TPDOC'	, 'JR' )
	oSubFK6:SetValue( 'FK6_VALCAL'	, nJuros )	
	oSubFK6:SetValue( 'FK6_VALMOV'	, nJuros )
	oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
	oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
	oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0018) ) //JUROS DE ADIANTAMENTO"
	If ( If( cPaisLoc <> "CHI", nJuros > 0, nOtrga > 0 ) ) .AND. lMovBcoBx
		oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )	
	Endif
	cCamposE5 += ",{'E5_VLJUROS' , Val('" + cValToChar( nJuros ) + "')}"
EndIf

If nMulta <> 0
	//Adicionando valores acessórios (Multa)
	If !oSubFK6:IsEmpty()
		oSubFK6:AddLine()
	EndIf
	oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
	oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
	oSubFK6:SetValue( 'FK6_TPDOC'	, 'MT' )
	oSubFK6:SetValue( 'FK6_VALCAL'	, nMulta )	
	oSubFK6:SetValue( 'FK6_VALMOV'	, nMulta )
	oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
	oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
	oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0019) )  //MULTA DE ADIANTAMENTO  
	If lMovBcoBx
		oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
	Endif
	cCamposE5 += ",{'E5_VLMULTA' , Val('" + cValToChar(nMulta) + "')}"
EndIf

If nDescont <> 0
	//Adicionando valores acessórios (Desconto)
	If !oSubFK6:IsEmpty()
		oSubFK6:AddLine()
	EndIf
	oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
	oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
	oSubFK6:SetValue( 'FK6_TPDOC'	, 'DC' )
	oSubFK6:SetValue( 'FK6_VALCAL'	, nDescont )	
	oSubFK6:SetValue( 'FK6_VALMOV'	, nDescont )
	oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
	oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
	oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0020) ) //DESCONTO DE ADIANTAMENTO 
	If lMovBcoBx
		oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
	Endif
	cCamposE5 += ",{'E5_VLDESCO' , Val('" + cValToChar( nDescont ) + "')}"
EndIf

If nCm <> 0
	//Adicionando valores acessórios (Juros)
	If !oSubFK6:IsEmpty()
		oSubFK6:AddLine()
	EndIf
	oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
	oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
	oSubFK6:SetValue( 'FK6_TPDOC'	, 'CM' )
	oSubFK6:SetValue( 'FK6_VALCAL'	, nCm )	
	oSubFK6:SetValue( 'FK6_VALMOV'	, nCm )
	oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
	oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
	oSubFK6:SetValue( 'FK6_HISTOR'	, OemToAnsi(STR0021) ) //CORREC.DE ADIANTAMENTO 
	If lMovBcoBx
		oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
	Endif
EndIf

nVlAcres := SE1->E1_SDACRES
If nVlAcres <> 0
	nVlAcres := Round( NoRound( xMoeda( nVlAcres, SE1->E1_MOEDA, 1, dBaixa, 3, SE1->E1_TXMOEDA ), 3 ), 2 )
	cCamposE5 += ",{'E5_VLACRES' , Val('" + cValToChar(nVlAcres) + "')}"
EndIf

nVlDecre := SE1->E1_SDDECRE
If nVlDecre <> 0
	nVlDecre := Round( NoRound( xMoeda( nVlDecre, SE1->E1_MOEDA, 1, dBaixa, 3, SE1->E1_TXMOEDA ), 3 ), 2 )	
	cCamposE5 += ",{'E5_VLDECRE' , Val('" + cValToChar(nVlDecre) + "')}"
EndIf

//Verifica se a baixa movimenta extrato para gerar FK5
If cTpDoc == "VL"
	If !oSubFKA:IsEmpty()
		oSubFKA:AddLine()
	EndIf
	
	cIdFK5 := FWUUIDV4()
	oSubFKA:SetValue( "FKA_IDORIG"	, cIdFK5 )
	oSubFKA:SetValue( "FKA_TABORI"	, 'FK5' )
	
	oSubFK5:SetValue( "FK5_DATA"	, dBaixa )	
	oSubFK5:SetValue( "FK5_DTDISP" 	, DTOS( Iif( EMpty(dDtCredito), dBaixa, dDtCRedito ) ) ) 
	oSubFK5:SetValue( "FK5_BANCO"  	, cBanco )
	oSubFK5:SetValue( "FK5_AGENCI" 	, cAgencia )
	oSubFK5:SetValue( "FK5_CONTA"  	, cConta )
	oSubFK5:SetValue( "FK5_ORIGEM" 	, cOrigem )
	oSubFK5:SetValue( "FK5_LA" 		, Iif( lPadrao .AND. lContabiliza, "S", "N" ) )
	oSubFK5:SetValue( "FK5_MOEDA"	, StrZero(nMoedaBco,2) )
	oSubFK5:SetValue( "FK5_NATURE"	, SE1->E1_NATUREZ )
	oSubFK5:SetValue( "FK5_RECPAG"	, "P" )
	oSubFK5:SetValue( "FK5_HISTOR"	, cHist070 )
	oSubFK5:SetValue( "FK5_SEQ"		, cSequencia )
	oSubFK5:SetValue( "FK5_DOC"		, SE1->E1_NUMBOR )
	oSubFK5:SetValue( "FK5_TPDOC"	, cTpDoc )
	oSubFK5:SetValue( "FK5_CCUSTO"	, SE1->E1_CCUSTO )
	oSubFK5:SetValue( "FK5_FILORI"	, SE1->E1_FILORIG )
	oSubFK5:SetValue( "FK5_VALOR"	, nValRec )
EndIf

cCamposE5 += " } "

If cPaisLoc $ "ARG|ANG|COL|MEX"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gerar a Movimentacao Bancaria na 2a. Moeda.  		  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SA6->( dbSeek(xFilial("SA6")+cBanco+cAgencia+cConta) )
	If !Empty(SA6->A6_MOEDA) .and. ( SA6->A6_MOEDA != SE1->E1_MOEDA )
		//Define os campos que não existem nas FKs e que serão gravados apenas na E5, para que a gravação da E5 continue igual
		If !Empty(cCamposE5)
		    cCamposE5 += "|"
		Endif
		cCamposE5 += " { "
		cCamposE5 += "{'E5_FILIAL'		,'" + cFilSE5 + "'}"
		cCamposE5 += ",{'E5_PREFIXO'	,'" +  SE1->E1_PREFIXO+ "'}"
		cCamposE5 += ",{'E5_NUMERO'		,'" +  SE1->E1_NUM + "'}"
		cCamposE5 += ",{'E5_PARCELA'	,'" +  SE1->E1_PARCELA + "'}"
		cCamposE5 += ",{'E5_CLIENTE'	,'" +  SE1->E1_CLIENTE + "'}"
		cCamposE5 += ",{'E5_CLIFOR'		,'" +  SE1->E1_CLIENTE + "'}"
		cCamposE5 += ",{'E5_LOJA'		,'" +  SE1->E1_LOJA + "'}"
		cCamposE5 += ",{'E5_BENEF'		,'" +  SE1->E1_NOMCLI + "'}"
		cCamposE5 += ",{'E5_TIPO'		,'" +  SE1->E1_TIPO + "'}"
		cCamposE5 += ",{'E5_DTDIGIT'	, STOD('" + DTOS(dDataBase) + "')}"
		cCamposE5 += ",{'E5_BANCO'		,'" +  cBanco + "'}"
		cCamposE5 += ",{'E5_AGENCIA'	,'" + cAgencia + "'}"
		cCamposE5 += ",{'E5_CONTA'		,'" +  cConta + "'}"
		cCamposE5 += ",{'E5_DTDISPO'	, STOD('" + DTOS( Iif( Empty(dDtCredito), dBaixa, dDtCRedito ) ) + "')}"
		If lSpbInUse
			cCamposE5 += ",{'E5_MODSPB'		, '1'}"
		EndIf
		cCamposE5 += " } "
		
		//Baixa Principal
		If !oSubFKA:IsEmpty()
			oSubFKA:AddLine()
		EndIf
		
		cIdFK1 := FWUUIDV4()
		oSubFKA:SetValue( "FKA_IDORIG"	, cIdFK1 )
		oSubFKA:SetValue( "FKA_TABORI"	, 'FK1' )
		
		If !oSubFK1:IsEmpty()
			oSubFK1:AddLine()
		EndIf
		
		cTpDoc := Iif( lMovBcoBx, "VL", "BA" )
		
		//Gera movimentação bancária a pagar - baixa do adiantamento
		oSubFK1:SetValue( "FK1_DATA"	, dBaixa )		
		oSubFK1:SetValue( "FK1_NATURE"	, SE1->E1_NATUREZ )
		oSubFK1:SetValue( "FK1_RECPAG"	, "P" )
		oSubFK1:SetValue( "FK1_HISTOR"	, cHist070 )
		oSubFK1:SetValue( "FK1_MOTBX"	, TrazCodMot( cMotBx ) )
		oSubFK1:SetValue( "FK1_ORIGEM"	, cOrigem )
		oSubFK1:SetValue( "FK1_SEQ"		, cSequencia )
		oSubFK1:SetValue( "FK1_DOC"		, SE1->E1_NUMBOR )
		oSubFK1:SetValue( "FK1_IDDOC"	, cChaveFK7 )
		oSubFK1:SetValue( "FK1_TPDOC"	, cTpDoc )	
		oSubFK1:SetValue( "FK1_CCUSTO"	, SE1->E1_CCUSTO )	
		oSubFK1:SetValue( "FK1_FILORI"	, SE1->E1_FILORIG )
		oSubFK1:SetValue( "FK1_MOEDA"	, StrZero( nMoedaBco, 2 ) )
		oSubFK1:SetValue( "FK1_LA"	   	, Iif( lPadrao .AND. lContabiliza, "S", "N" ) )
		oSubFK1:SetValue( "FK1_LOTE"   	, cLoteFin )
		oSubFK1:SetValue( "FK1_VALOR"	, xMoeda( nValRec, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )			
		If nValEstrang != 0
			oSubFK1:SetValue( "FK1_VLMOE2"	, nValEstrang )
			oSubFK1:SetValue( "FK1_TXMOED"	, Max( nTxMdTit, nTxMdBco ) )
		Else
			oSubFK1:SetValue( "FK1_VLMOE2"	, xMoeda( nValRec, 1, SA6->A6_MOEDA ) )
		EndIf
				
		If nJuros <> 0
			//Adicionando valores acessórios (Juros)
			If !oSubFK6:IsEmpty()
				oSubFK6:AddLine()
			EndIf
			oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
			oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
			oSubFK6:SetValue( 'FK6_TPDOC'	, 'JR' )
			oSubFK6:SetValue( 'FK6_VALCAL'	, xMoeda(nJuros+nOtrga,nMoedaTit,nMoedaBco,,, nTxMdTit, nTxMdBco ) )	
			oSubFK6:SetValue( 'FK6_VALMOV'	, xMoeda(nJuros+nOtrga,nMoedaTit,nMoedaBco,,, nTxMdTit, nTxMdBco ) )
			oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
			oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
			oSubFK6:SetValue( 'FK6_HISTOR'	, cHist070 )
			If nJuros > 0 .AND. lMovBcoBx
				oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )	
			Endif
		EndIf
		
		If nCm <> 0
			//Adicionando valores acessórios (Juros)
			If !oSubFK6:IsEmpty()
				oSubFK6:AddLine()
			EndIf
			oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
			oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
			oSubFK6:SetValue( 'FK6_TPDOC'	, 'CM' )
			oSubFK6:SetValue( 'FK6_VALCAL'	, xMoeda( nCM, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )	
			oSubFK6:SetValue( 'FK6_VALMOV'	, xMoeda( nCM, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )
			oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
			oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
			oSubFK6:SetValue( 'FK6_HISTOR'	, cHist070 ) 
			If lMovBcoBx
				oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
			Endif
		EndIf
		
		If nDescont <> 0
			//Adicionando valores acessórios (Desconto)
			If !oSubFK6:IsEmpty()
				oSubFK6:AddLine()
			EndIf
			oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
			oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
			oSubFK6:SetValue( 'FK6_TPDOC'	, 'DC' )
			oSubFK6:SetValue( 'FK6_VALCAL'	, xMoeda( nDescont, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )	
			oSubFK6:SetValue( 'FK6_VALMOV'	, xMoeda( nDescont, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )
			oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
			oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
			oSubFK6:SetValue( 'FK6_HISTOR'	, cHist070 ) 
			If lMovBcoBx
				oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
			Endif
		EndIf
				
		If nMulta <> 0
			//Adicionando valores acessórios (Multa)
			If !oSubFK6:IsEmpty()
				oSubFK6:AddLine()
			EndIf
			oSubFK6:SetValue( 'FK6_IDFK6'	, GetSxEnum('FK6','FK6_IDFK6') )											
			oSubFK6:SetValue( 'FK6_TABORI'	, 'FK1' )
			oSubFK6:SetValue( 'FK6_TPDOC'	, 'MT' )
			oSubFK6:SetValue( 'FK6_VALCAL'	, xMoeda( nMulta, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )	
			oSubFK6:SetValue( 'FK6_VALMOV'	, xMoeda( nMulta, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )
			oSubFK6:SetValue( 'FK6_RECPAG'	, "P" )
			oSubFK6:SetValue( 'FK6_IDORIG'	, cIdFK1 )
			oSubFK6:SetValue( 'FK6_HISTOR'	, cHist070 ) //MULTA DE ADIANTAMENTO"
			If lMovBcoBx
				oSubFK6:SetValue( 'FK6_GRVSE5'	, .T. )
			Endif
		EndIf
		
		//Verifica se a baixa movimenta extrato para gerar FK5
		If cTpDoc == "VL"
			nRetencao	:= SA6->A6_RETENCA
			dDataDisp	:= dBaixa
			If nRetencao > 0
				For nCont := 1 To nRetencao
					dDataDisp 	:= DataValida(dDataDisp+1,.T.)
				Next nCont
			Endif
		
			If !oSubFKA:IsEmpty()
				oSubFKA:AddLine()
			EndIf
			
			cIdFK5 := FWUUIDV4()
			oSubFKA:SetValue( "FKA_IDORIG"	, cIdFK5 )
			oSubFKA:SetValue( "FKA_TABORI"	, 'FK5' )
			
			oSubFK5:SetValue( "FK5_DATA"	, dBaixa )	
			oSubFK5:SetValue( "FK5_DTDISP" , dDataDisp  ) 
			oSubFK5:SetValue( "FK5_BANCO"  	, cBanco )
			oSubFK5:SetValue( "FK5_AGENCI" 	, cAgencia )
			oSubFK5:SetValue( "FK5_CONTA"  	, cConta )
			oSubFK5:SetValue( "FK5_ORIGEM" 	, cOrigem )
			oSubFK5:SetValue( "FK5_LA" 		, Iif( lPadrao .AND. lContabiliza, "S", "N" ) )
			oSubFK5:SetValue( "FK5_MOEDA"	, StrZero( nMoedaBco, 2 ) )
			oSubFK5:SetValue( "FK5_NATURE"	, SE1->E1_NATUREZ )
			oSubFK5:SetValue( "FK5_RECPAG"	, "P" )
			oSubFK5:SetValue( "FK5_HISTOR"	, cHist070 )
			oSubFK5:SetValue( "FK5_SEQ"		, cSequencia )
			oSubFK5:SetValue( "FK5_DOC"		, SE1->E1_NUMBOR )
			oSubFK5:SetValue( "FK5_TPDOC"	, cTpDoc )
			oSubFK5:SetValue( "FK5_CCUSTO"	, SE1->E1_CCUSTO )
			oSubFK5:SetValue( "FK5_FILORI"	, SE1->E1_FILORIG )
			oSubFK5:SetValue( "FK5_VALOR"	, xMoeda( nValRec, nMoedaTit, nMoedaBco, , , nTxMdTit, nTxMdBco ) )							
			If nValEstrang != 0
				oSubFK5:SetValue( "FK5_VLMOE2"	, nValEstrang )
				oSubFK5:SetValue( "FK5_TXMOED"	, Max( nTxMdTit, nTxMdBco ) )
				oSubFK5:SetValue( "FK5_MOEDA"	, StrZero( nMoedaBco, 2 ) )
			Else
				oSubFK5:SetValue( "FK5_VLMOE2"	, xMoeda( nValRec, 1, SA6->A6_MOEDA ) )
			EndIf									
		EndIf
	
	EndIf
	
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se a baixa for menor que o valor adiantado emite-se um cheque para		³
//³ devolver o que sobrou, Se baixa n„o for GERAR MOVIMENTACAO BANCARIA, 	³
//³ esse cheque n„o ser  gerado, pois o valor adiantado n„o sera devolvido.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lGerChqAdt .And. nValRec > 0 .and. lMovBcoBx .and. ChqMotBx(cMotBx)
	cChaveCH := FWUUIDV4()
	RecLock("SEF",.T.)
	SEF->EF_FILIAL	:= xFilial("SEF")
	SEF->EF_BANCO		:= cBanco
	SEF->EF_AGENCIA	:= cAgencia
	SEF->EF_CONTA		:= cConta
	SEF->EF_VALOR		:= nValRec
	SEF->EF_DATA		:= dBaixa
	SEF->EF_BENEF		:= SE1->E1_NOMCLI
	SEF->EF_HIST		:= OemToAnsi(STR0016) + SE1->E1_HIST//"Devolucao de Adiantamento"
	SEF->EF_PREFIXO	:= SE1->E1_PREFIXO
	SEF->EF_TITULO	:= SE1->E1_NUM
	SEF->EF_PARCELA	:= SE1->E1_PARCELA
	SEF->EF_FORNECE	:= SE1->E1_CLIENTE
	SEF->EF_LOJA		:= SE1->E1_LOJA
	SEF->EF_TIPO		:= SE1->E1_TIPO
	SEF->EF_SEQUENC	:= PadL( "1", TamSX3("EF_SEQUENC")[1], "0" )
	SEF->EF_ORIGEM	:= "FINA070"
	SEF->EF_IDSEF		:= cChaveCH
	
	//Vincula cheque ao processo na FKA 
	If !oSubFKA:IsEmpty()
		oSubFKA:AddLine()
	Endif							
	oSubFKA:SetValue( 'FKA_IDORIG', cChaveCH )			
	oSubFKA:SetValue( 'FKA_TABORI', 'SEF' )
Endif

//Grava os dados da Baixa a Receber Automática
oModelBxR:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 )
If oModelBxR:VldData()
	oModelBxR:CommitData()	
	//Pega o Recno da baixa principal	
	nRecBx := oModelBxR:GetValue("MASTER","E5_RECNO")	
Else
	lRet := .F.
	cLog := cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_IDFIELDERR]) + ' - '
	cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_ID]) + ' - '
	cLog += cValToChar(oModelBxR:GetErrorMessage()[MODEL_MSGERR_MESSAGE])         	
	Help( ,,"M10F70AD01",,cLog, 1, 0 )   
	nRecBx := 0 
EndIf
oModelBxR:DeActivate()
oModelBxR:Destroy()
oModelBxR := NIL

//Chama o ponto de entrada "FA070ADTSE5" para cada registro gravado na SE5 
If lFA070ADTSE5
	If nRecBx > 0
		SE5->( DbGoto( nRecBx ) )
		ExecBlock("FA070ADTSE5",.F.,.F.)
	Endif
	
	//Pega os Recnos dos registros de SE5 referentes a FK6
	aRecsSe5 := FK6SE5Recs()
	For nI := 1 To Len( aRecsSe5 )
		SE5->( DbGoto( aRecsSe5[nI] ) )						
		ExecBlock("FA070ADTSE5",.F.,.F.)		
	Next nI
EndIf

//Retorna posicionamento da E5
SE5->( DbGoto( nRecBx ))

//Guardo informacoes da baixa para calculo de comissao quando baixa de NCC gerada por liquidacao
If !( Empty(SE1->E1_NUMLIQ) )
	aAdd( aBaixas, { TrazCodMot( cMotBx ), cSequencia, nRecBx } )
Endif

// Integração SIGAPFS x SIGAFIN
If lRet .And. FindFunction("JGrvBxRA")
	lRet := JGrvBxRA(SE1->(Recno())) // Atualiza valores de adiantamento
EndIf

Return


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FILISSTRAN

Retorna a filial de origem do ISS, caso o mesmo não tenha sido transferido junto com os demais impostos.
Arquivo anterior: FINXATU.PRX

@Author	Daniel Mendes
@since	20/10/2014
/*/
//-----------------------------------------------------------------------------------------------------
Function FilISSTran()
Local cFilRetIss := ""
Local aArea      := GetArea()
Local aAreaSE6   := SE6->(GetArea())
Local aAreaSE1   := SE1->(GetArea())
Local lTrfISSf   := GetNewPar( "MV_TRFISSF" , .T. )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Busca origem do titulo baixado se foi originado pelo FINA630  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If "FINA630" $ SE1->E1_ORIGEM .And. !lTrfISSf
	DbSelectArea("SE6")
	SE6->(DbSetOrder(4))

	If SE6->(DbSeek(xFilial("SE1")+SE1->(E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)))
		While !SE6->(Eof()) .And. SE6->(E6_FILIAL+E6_PREFIXO+E6_NUM+E6_PARCELA+E6_TIPO) == SE1->(E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO)
			cFilRetIss := IIf( SE6->E6_SITSOL == "2" , SE6->E6_FILORIG , "" )
			SE6->(dbSkip())
		EndDo
	EndIf

	RestArea( aAreaSE1 )
	RestArea( aAreaSE6 )
	RestArea( aArea    )
EndIf

Return cFilRetIss

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070VALMO

Consiste o motivo de baixa em relação a situação de cobrança do t¡tulo (FINA070).
Arquivo anterior: FINXATU.PRX

@Author	Valter G. Nogueira Jr
@since	04/03/1994
/*/
//-----------------------------------------------------------------------------------------------------
Function Fa070ValMo()
Local lRet := .T.

//---------------------------------------------------------
// Ponto de Entrada para o usuário fazer	a sua própria 
// validação a respeito do motivo da baixa.			  
//---------------------------------------------------------
If lF070VMOT
	lRet := ExecBlock("F070VMOT",.F.,.F.)
	Return lRet
Endif
//Situacao de cobranca diferente de Carteira e motivo de baixa nao movimenta banco
If !(FN022SITCB(SE1->E1_SITUACA)[1]) .and. !MovBcoBx(cMotBx, .T.)
	lRet := .F.
EndIf

If ! lRet
	Help(" ",1,"FA070MOTINV")
Endif

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070ESTRANG

Função utilizada para consistir o valor digitado em moeda estrangeira.
Arquivo anterior: FINXATU.PRX

@Author	Wilson Junior
@since	26/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fa070Estrang(nTxMoeda)
Local lRet		:= .T.
Local nSaldtit	:= nValEstrang - Round(xMoeda(nJuros + nVA +nMulta-nDescont+nAcresc-nDecresc,nMoedaBco,SE1->E1_MOEDA,dBaixa,3,,nTxMoeda),2)

If lFA070CMI
	ExecBlock("FA070CMI",.F.,.F.)
Endif

If Int(nSaldtit) > Int(SE1->E1_SALDO)
	lRet := .F.
EndIf

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ULTILOTE

Ponto de entrada para buscar número do ultimo lote digitado (FINA070/FINA080/FINA090).
Arquivo anterior: FINXATU.PRX

@Author	Mauricio Pequim Jr.
@since	14/10/1997
/*/
//-----------------------------------------------------------------------------------------------------
Function Ultilote()
Default lUltiLote := ExistBlock("UltiLote")

//---------------------------------------------------------
// PONTO DE ENTRADA
//---------------------------------------------------------
If lUltiLote
	ExecBlock('UltiLote',.F.,.F.)
EndIf

Return .T.

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} CHECKLOTE

Verifica se um lote ja existe
Arquivo anterior: FINXATU.PRX

@Author	Wagner Xavier
@since	06/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function CheckLote(cRecPag,lHelp)
Local aAreaAnt	:= {}
Local aAreaSe5	:= {}
Local lRet 	 	:= .T.
Local lBxCnab	:= IIf( SuperGetMv( "MV_BXCNAB",,"S" ) == "S", .T., .F. )
Local cFunName	:= FunName()
Default cRecPag	:= "P"
Default lHelp 	:= !(IsBlind())

If cFunName $ "FINA090|FINA091" .AND. lBxCnab .AND. ( ( SubStr( cBco090, 1, 2 ) == "CX" .OR. cBco090 $ SuperGetMv("MV_CARTEIR",,"")  ) ) 
    lRet:= .T.
Elseif Empty (cLoteFin)
	lRet:= .F.
EndIF

If lRet
	aAreaAnt := GetArea()
	aAreaSe5 := SE5->( GetArea() )

	dbSelectArea("SE5")
	SE5->( dbSetOrder( 5 ) )	
	If !Empty( cLoteFin )
		If msSeek( FWxFilial("SE5") + cLoteFin )
			While SE5->( !Eof() ) .AND. AllTrim(SE5->E5_LOTE) == AllTrim(cLoteFin) .AND. SE5->E5_FILIAL == FWxFilial("SE5")
				If SE5->E5_RECPAG == cRecPag
					If lHelp
						Help( "", 1, "LOTEEXIST" )
					EndIf
					lRet := .F.
					Exit
				Endif
				SE5->( dbSkip() )
			Enddo
		Endif
	Endif
		
	SE5->( RestArea(aAreaSe5) )
	RestArea( aAreaAnt )	
Endif

Return lRet

//--------------------------------------------------------------------------------
// Funcoes retiradas do arquivo FINXFUN.PRX                     
//--------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} SHOWMOTBX

Valida se mostra na tela a tabela de motivos da baixa (FINA090/FINA110).
Arquivo anterior: FINXFUN.PRX

@Author	Andreia Sandos
@since	25/11/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function ShowMotBx(cCarteira,lAut)
Local lRet  := .T.

lAut := IIF(lAut == NIL, .F.,lAut)

Return( lRet)

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} VLDBANCO

Validar a existencia dos codigos de Banco, Agencia e Conta e ainda se existe Bloqueio do registro.
Arquivo anterior: FINXFUN.PRX

@Author	Norberto M. Melo
@since	03/09/2007
/*/
//-----------------------------------------------------------------------------------------------------
Function VldBanco()
LOCAL lRet := .T.

If !Empty(M->E5_BANCO) .and. !Empty(M->E5_AGENCIA) .and. !Empty(M->E5_CONTA)
		lRet := ExistCpo("SA6", M->(E5_BANCO+E5_AGENCIA+E5_CONTA))
ElseIf !Empty(M->E5_BANCO) .and. !Empty(M->E5_AGENCIA)
	lRet := Existcpo("SA6",M->(E5_BANCO+E5_AGENCIA),,,,.F.)
Else
	lRet := Existcpo("SA6",M->E5_BANCO,,,,.F.)
Endif
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} CHQMOTBX

Verifica se o motivo de baixa gera cheque.
Arquivo anterior: FINXFUN.PRX

@Author	Mauricio Pequim Jr.
@since	31/03/1999
/*/
//-----------------------------------------------------------------------------------------------------
Function ChqMotBx( cMotBx )
Local nPos		:= 0
Local lRet	 	:= .F.
Local aMotBx	:= ReadMotBx()

nPos := Ascan(aMotBx, {|x| Alltrim(Substr(x,7,10)) == Alltrim(Upper(cMotBx))})
If nPos > 0
	lRet := Iif(Substr(aMotBx[nPos],41,1) == "S",.T.,.F.)
Endif
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} TRAZCODMOT

Retorna o codigo reduzido (sigla) do motivo de baixa.
Arquivo anterior: FINXFUN.PRX

@Author	Andreia Santos
@since	04/12/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function TrazCodMot( cMotBx )
Local nPos		:= 0
Local lRet 		:= cMotBx
Local aMotBx	:= ReadMotBx()

nPos := Ascan(aMotBx, {|x| AllTrim(Substr(x,7,10)) == Upper(AllTrim(cMotBx))})
If nPos>0
	lRet := Substr(aMotBx[nPos],1,3)
Else
	lRet := left(cMotBx,3)
EndIf
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} BAIXAS

Retorna uma matriz com os valores pagos ou recebidos de um titulo (FINA040/FINR340).
Arquivo anterior: FINXFUN.PRX

@Author	Luis C. Cunha
@since	04/12/1998
/*/
//-----------------------------------------------------------------------------------------------------
Function Baixas(cNatureza,cPrefixo,cNumero,cParcela,cTipo,nMoeda,cModo,cFornec,dData,cLoja,cFilTit,dDtIni,dDtFin,lConsDtBas,lMovM2)
STATIC aMotBaixas
STATIC lFVerRstFin 	:= .t.
STATIC nTamTit		:= 0
STATIC lE5Origem
STATIC _lPCCBaixa
STATIC _lContrRet
STATIC _lImpComp
STATIC _lRastro
STATIC lVlAcreDesc

Local aRetorno		:= {0,0,0,0,0,0,0,0," ",0,0,0,0,0,0,0,0,0,0,0}
Local cArea   		:= Alias()
Local aArea			:= getArea()
Local nOrdem  		:= 0
Local nMoedaTit
Local lNaoConv
Local aMotBx 		:= {}
Local nI 			:= 0
Local nT 			:= 0
Local lDataNil 		:= ( dData == Nil )
Local nMoedaCalc	:= 0
Local cQuery		:= ""
Local cAliasSE5		:= getNextAlias()

DEFAULT _lImpComp 	:= SuperGetMv("MV_IMPCMP",,"2") == "1"
DEFAULT lVlAcreDesc := .T.
DEFAULT _lRastro 	:= If(lFVerRstFin, FVerRstFin(),.F.) .and. SuperGetMV("MV_NRASDSD",.T.,.F.) //Rastreamento
DEFAULT lE5Origem	:= .T.  //se a origem da Baixa é do SIGALOJA e TipoDoc for VL , não usa na composicao do valor da baixa
Default cFilTit		:= xFilial("SE5")
Default lConsDtBas 	:= .T.
Default nTamTit		:= TamSX3("E1_PREFIXO")[1]+TamSX3("E1_NUM")[1]+TamSX3("E1_PARCELA")[1]+1
Default _lPCCBaixa	:= SuperGetMv("MV_BX10925",.T.,"2") == "1"
Default _lContrRet	:= .T.
Default lMovM2 := .F.

If aMotBaixas == NIL
	// Monto array com codigo e descricao do motivo de baixa
	aMotBx := ReadMotBx()
	aMotBaixas := {}
	For NI := 1 to Len(aMotBx)
		AADD( aMotBaixas,{substr(aMotBx[nI],01,03),substr(aMotBx[nI],07,10)})
	Next
Endif

// Quando eh chamada do Excel, estas variaveis estao em branco
IF Empty(MVABATIM) .Or.;
	Empty(MV_CRNEG) .Or.;
	Empty(MVRECANT) .Or.;
	Empty(MV_CPNEG) .Or.;
	Empty(MVPAGANT) .Or.;
	Empty(MVPROVIS)
	CriaTipos()
Endif

cFornec	:= IIF( cFornec == NIL , "", cFornec )
cLoja 	:= IIF( cLoja == NIL , "" , cLoja )
nMoeda	:= IIf( nMoeda == NIL , 1 , nMoeda )

dData	:= IIf( lDataNil , dDataBase , dData )
dDtIni	:= IIf( dDtIni == NIL ,CTOD("//") , dDtIni )
dDtFin	:= IIf( dDtFin == NIL ,CTOD("//") , dDtFin )

#ifdef TOP
	If ( TcSrvType()!="AS/400" )
		cQuery := " SELECT E5_FILIAL, E5_PREFIXO , E5_NUMERO , E5_PARCELA , E5_TIPO , E5_BANCO , E5_MOEDA , E5_RECPAG , E5_CLIFOR, E5_LOJA , "
		cQuery += " E5_DATA , E5_TIPODOC, E5_VALOR , E5_TXMOEDA , E5_MOTBX , E5_VLMOED2 , E5_VRETPIS , E5_VRETCOF , E5_VRETCSL , "
		cQuery += " E5_VLACRES , E5_VLDECRE , E5_SEQ, E5_PRETPIS, E5_DOCUMEN "
		If lE5Origem
			cQuery += ", E5_ORIGEM "
		EndIf
		cQuery += " FROM "+RetSqlName("SE5")
		cQuery += Iif(FunName() $ "FINR350" .And. !Empty(cFilTit), " WHERE (E5_FILIAL = '"+cFilTit+"' OR E5_FILORIG = '"+cFilTit+"') ", " WHERE E5_FILIAL = '"+cFilTit+"' ")
		cQuery += " AND E5_PREFIXO = '"+cPrefixo+"' "
		cQuery += " AND E5_NUMERO = '"+cNumero+"' "
		cQuery += " AND E5_PARCELA = '"+cParcela+"' "
		cQuery += " AND E5_TIPO = '"+cTipo+"' "
		cQuery += " AND E5_CLIFOR = '"+cFornec+"' "
		cQuery += " AND E5_LOJA = '"+cLoja+"' "
		cQuery += " AND E5_SITUACA != 'C' "
		cQuery += " AND E5_TIPODOC != 'ES' "
		IF lConsDtBas
			If lDataNil
				cQuery += " AND ( E5_DATA <= '" + DtoS(dDataBase) + "' "
			Else
				cQuery += " AND ( E5_DATA <= '" + Dtos(Min( dData , dDataBase) ) + "' "
			Endif
			cQuery += " ) "
		Endif
		If !Empty(dDtIni)
			cQuery += " AND ( E5_DATA BETWEEN '"+DtoS(dDtIni)+"' AND '"+DtoS(dDtFin)+"' ) "
		Endif
		cQuery += " AND D_E_L_E_T_ = ' ' "

		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasSE5 , .F., .T.)

		nMoedaTit := Iif( cModo == "R", SE1-> E1_MOEDA , SE2 -> E2_MOEDA )

		While (cAliasSE5)->( !EOF() )

			//Nas localizacoes e usada a movimentacao bancaria em mais de uma moeda
			//por isso, quando a baixa for contra um banco, devo pegar a E5_VLMOED2,
			//pois na E5_VALOR, estara grvado o movimento na moeda do banco.
			//Bruno. Paraguay 23/08/00
			lNaoConv	:=	(nMoeda == 1 .And.(cPaisLoc=="BRA".Or.Empty(E5_BANCO)).or.( nMoeda==Val( (cAliasSE5)->E5_MOEDA) .And. cPaisLoc<>"BRA" .And. !Empty(E5_BANCO)) )
			Do Case
			// Despresa as movimenta‡oes diferentes do tipo solicitado somente se
			// o tipo for != de RA e PA, pois neste caso o RECPAG sera invertido.
			Case (cAliasSE5)->E5_RECPAG != cModo .AND. !( (cAliasSE5)->E5_TIPO $ MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG) ;
				.AND. E5_TIPODOC != "CM"
				dbSkip()
				Loop
			Case TemBxCanc( (cAliasSE5)->( E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ ) )
				dbSkip()
				Loop
			Case lE5Origem .AND. AllTrim((cAliasSE5)->E5_ORIGEM) == 'LOJXREC' .AND. (cAliasSE5)->E5_TIPODOC $ "VL"
				dbSkip()
				Loop
			Case (cAliasSE5)->E5_TIPODOC $ "VLüBA/V2/CP"
				IF cModo == "R"
					If Alltrim(FunName()) $ "FINR340"  .And. cPaisLoc == "MEX"
						aRetorno[5]+=xMoeda((cAliasSE5)->E5_VALOR,Val((cAliasSE5)->E5_MOEDA),nMoeda,(cAliasSE5)->E5_DATA,,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,))
					Else
						aRetorno[5]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VLMOED2,nMoedaTit,nMoeda,(cAliasSE5)->E5_DATA,,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
					EndIf
					If (cAliasSE5)->E5_MOTBX == "CMP" .and. SUBSTR((cAliasSE5)->E5_DOCUMEN,nTamTit,3) == MV_CRNEG  //NCC
						aRetorno[13]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VALOR,nMoedaTit,nMoeda,(cAliasSE5)->E5_DATA,,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
						If _lImpComp
							//Retorno valores de Pis e Cofins para as compensacoes
							aRetorno[14]+= (cAliasSE5)->E5_VRETPIS
							aRetorno[15]+= (cAliasSE5)->E5_VRETCOF
							aRetorno[18]+= (cAliasSE5)->E5_VRETCSL
						Endif
					Endif
					//Retorno valor baixado via liquidacao
					If (cAliasSE5)->E5_MOTBX == "LIQ"
						aRetorno[19]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VALOR,nMoedaTit,nMoeda,(cAliasSE5)->E5_DATA,,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
					Endif

					//Retorno valor baixado via Desdobramento com rastro
					If (cAliasSE5)->E5_MOTBX == "DSD" .and. _lRastro
						aRetorno[20]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VALOR,nMoedaTit,nMoeda,(cAliasSE5)->E5_DATA,,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
					Endif
				Else
					//Baixa PA nao deve ser considerada
					If !((cAliasSE5)->E5_TIPODOC == "BA" .and. (cAliasSE5)->E5_TIPO == "PA " .and. (cAliasSE5)->E5_RECPAG == "P" .and. (cAliasSE5)->E5_MOTBX <> "CMP")

						//Se nao converte
						If (lNaoConv .And. cPaisLoc == "BRA") .Or. (cPaisLoc <> "BRA" .And. nMoeda == nMoedaTit)
							If cPaisLoc == "BRA" .And. !lMovM2 .And. FwIsInCallStack("FINR350") .And. MovMoedEs((cAliasSE5)->E5_MOEDA, (cAliasSE5)->E5_TIPODOC, (cAliasSE5)->E5_MOTBX, (cAliasSE5)->E5_DATA) 
								aRetorno[6] += (cAliasSE5)->E5_VLMOED2
							Else
								aRetorno[6]+=	If((cAliasSE5)->E5_TIPODOC == "BA" .and. (cAliasSE5)->E5_TIPO == "PA " .and. (cAliasSE5)->E5_RECPAG == "P" .and. (cAliasSE5)->E5_MOTBX <> "CMP",0,Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda(Iif(cpaisLoc=="BRA",(cAliasSE5)->E5_VLMOED2,(cAliasSE5)->E5_VALOR),Iif(!Empty((cAliasSE5)->E5_MOEDA).And. cPaisLoc<>"BRA",Val((cAliasSE5)->E5_MOEDA),nMoedaTit),nMoeda,(cAliasSE5)->E5_DATA,,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,))))  
							EndIf
						Else
							//Se pais for Brasil ou
							// (Se a moeda do movimento estiver preenchida em outros paises ou
							//	 Se o registro for de compensacao
							//		(neste caso a moeda nao eh gravada e o valor na moeda do titulo esta no E5_VLMOED2)	)
							If cPaisLoc=="BRA" .Or. (( !Empty((cAliasSE5)->E5_MOEDA) .OR. (cAliasSE5)->E5_MOTBX == 'CMP') .And. cPaisLoc<>"BRA" )
								If FwIsInCallStack("FINR350") .And. MovMoedEs((cAliasSE5)->E5_MOEDA, (cAliasSE5)->E5_TIPODOC, (cAliasSE5)->E5_MOTBX, (cAliasSE5)->E5_DATA)
									nValor := Iif(lMovM2, (cAliasSE5)->E5_VALOR, (cAliasSE5)->E5_VLMOED2)   
								Else 
									nValor := (cAliasSE5)->E5_VLMOED2
								EndIf
							Else
								nValor := (cAliasSE5)->E5_VALOR
							Endif
							//Forço o valor para localização diferente de Brasil
							If cPaisLoc <> "BRA"
								nValor := (cAliasSE5)->E5_VALOR
							EndIf

							nMoedaCalc := IF(!Empty((cAliasSE5)->E5_MOEDA).And. cPaisLoc<>"BRA",Val((cAliasSE5)->E5_MOEDA),nMoedaTit)
							aRetorno[6]+= xMoeda(nValor,nMoedaCalc,nMoeda,STOD(((cAliasSE5)->E5_DATA)))
	      			Endif
	            Endif

					If _lContrRet .And. _lPCCBaixa .And. ((cAliasSE5)->E5_PRETPIS $ " #3")
						aRetorno[12]+= (cAliasSE5)->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
					Endif
				Endif
				aRetorno[10]+= (cAliasSE5)->E5_VALOR
				aRetorno[11]+= 1   // Numero de baixas

				If lVlAcreDesc
					aRetorno[16] += (cAliasSE5)->E5_VLACRES
					aRetorno[17] += (cAliasSE5)->E5_VLDECRE
				Endif

		Case (cAliasSE5)->E5_TIPODOC $ "DC/D2"
					aRetorno[2]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VLMOED2,nMoedaTit,nMoeda,STOD((cAliasSE5)->E5_DATA),Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
			Case (cAliasSE5)->E5_TIPODOC $ "JR/J2"
					aRetorno[3]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda(Iif(cpaisLoc=="BRA",(cAliasSE5)->E5_VLMOED2,(cAliasSE5)->E5_VALOR),Iif(!Empty((cAliasSE5)->E5_MOEDA).And. cPaisLoc<>"BRA",Val((cAliasSE5)->E5_MOEDA),nMoedaTit),nMoeda,STOD((cAliasSE5)->E5_DATA),,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
			Case (cAliasSE5)->E5_TIPODOC $ "MT/M2"
					aRetorno[4]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VLMOED2,nMoedaTit,nMoeda,STOD((cAliasSE5)->E5_DATA)))
			Case (cAliasSE5)->E5_TIPODOC $ "CM/C2/CX"
					aRetorno[1]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda(Iif(cpaisLoc=="BRA",(cAliasSE5)->E5_VLMOED2,(cAliasSE5)->E5_VALOR),Iif(!Empty((cAliasSE5)->E5_MOEDA) .And. cPaisLoc<>"BRA",Val((cAliasSE5)->E5_MOEDA),nMoedaTit),nMoeda,STOD((cAliasSE5)->E5_DATA),,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
			Case (cAliasSE5)->E5_TIPODOC $ "RA /"+MV_CRNEG
					aRetorno[7]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda((cAliasSE5)->E5_VLMOED2,nMoedaTit,nMoeda,STOD((cAliasSE5)->E5_DATA)))
			Case ((cAliasSE5)->E5_TIPODOC = "PA" .Or. (cAliasSE5)->E5_TIPO = "PA") .or. (cAliasSE5)->E5_TIPODOC $ MV_CPNEG
					aRetorno[8]+=Iif(lNaoConv,(cAliasSE5)->E5_VALOR,xMoeda(Iif(cpaisLoc=="BRA",(cAliasSE5)->E5_VLMOED2,(cAliasSE5)->E5_VALOR),Iif(!Empty((cAliasSE5)->E5_MOEDA) .And. cPaisLoc<>"BRA",Val((cAliasSE5)->E5_MOEDA),nMoedaTit),nMoeda,STOD((cAliasSE5)->E5_DATA),,Iif((cAliasSE5)->E5_TXMOEDA > 0,(cAliasSE5)->E5_TXMOEDA,)))
			EndCase
			If ! Empty((cAliasSE5)->E5_MOTBX )
				If (cAliasSE5)->E5_MOTBX == "NOR"
					aRetorno[9] := OemToAnsi( STR0008) //"Normal"
				Elseif (cAliasSE5)->E5_MOTBX == "DEV"
					aRetorno[9] := OemToAnsi( STR0009) //"Devolução"
				Elseif (cAliasSE5)->E5_MOTBX == "DAC"
					aRetorno[9] := OemToAnsi( STR0017)	//"DAÇÃO"
				Elseif (cAliasSE5)->E5_MOTBX == "VEN"
					aRetorno[9] := OemToAnsi( STR0010) //"VENDOR"
				Elseif (cAliasSE5)->E5_MOTBX == "CMP"
					aRetorno[9] := OemToAnsi( STR0011) //"Compensação"
				Elseif (cAliasSE5)->E5_MOTBX == "CEC"
					aRetorno[9] := OemToAnsi( STR0012) //"Comp Carteiras"
				Elseif (cAliasSE5)->E5_MOTBX == "DEB"
					aRetorno[9] := OemToAnsi( STR0013) //"Débito C/C"
				Elseif (cAliasSE5)->E5_MOTBX == "LIQ"
					aRetorno[9] := OemToAnsi( STR0014) //"Liquidação"
				Elseif (cAliasSE5)->E5_MOTBX == "FAT"
					aRetorno[9] := OemToAnsi( STR0015) //"Faturado"
				Else
					IF (nT := ascan(aMotBaixas,{|x| x[1]= (cAliasSE5)->E5_MOTBX })) > 0
						aRetorno[9] := aMotBaixas [nT][2]
					Endif
				Endif
			Endif
			(cAliasSE5)->( dbSkip() )
		Enddo
		(cAliasSE5)->( dbCloseArea() )
	Else
#ENDIF
	dbSelectArea("SE5")
	nOrdem:=IndexOrd()
	dbSetOrder(7)
	If MsSeek(cFilTit+cPrefixo+cNumero+cParcela+cTipo)

		nMoedaTit := Iif( cModo == "R", SE1-> E1_MOEDA , SE2 -> E2_MOEDA )

		While cFilTit+cPrefixo+cNumero+cParcela+cTipo==SE5->E5_FILIAL+;
				SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO

			//Nas localizacoes e usada a movimentacao bancaria em mais de uma moeda
			//por isso, quando a baixa for contra um banco, devo pegar a E5_VLMOED2,
			//pois na E5_VALOR, estara grvado o movimento na moeda do banco.
			//Bruno. Paraguay 23/08/00
			lNaoConv	:=	(nMoeda == 1 .And.(cPaisLoc=="BRA".Or.Empty(E5_BANCO)).or.( nMoeda==Val(SE5->E5_MOEDA) .And. cPaisLoc<>"BRA" .And. !Empty(E5_BANCO)) )
			Do Case
			Case AllTrim(SE5->E5_SITUACA) = "C" .or. ;
					SE5->E5_TIPODOC = "ES"
				dbSkip()
				Loop
			// Despresa as movimenta‡oes diferentes do tipo solicitado somente se
			// o tipo for != de RA e PA, pois neste caso o RECPAG sera invertido.
			Case SE5->E5_RECPAG != cModo .AND. !(SE5->E5_TIPO$MVRECANT+"/"+MVPAGANT+"/"+MV_CRNEG+"/"+MV_CPNEG)
				dbSkip()
				Loop
			Case TemBxCanc()
				dbSkip()
				Loop
			Case SE5->E5_CLIFOR+SE5->E5_LOJA != cFornec + cLoja
				dbSkip( )
				Loop
			Case (SE5->E5_DATA > dDataBase .or. SE5->E5_DATA > dData) .And. lConsDtBas
				dbSkip()
				Loop
			Case !Empty(dDtIni) .and. SE5->E5_DATA < dDtIni .and. SE5->E5_DATA > dDtFin
				dbSkip()
				Loop
			Case lE5Origem .AND. AllTrim(SE5->E5_ORIGEM) == 'LOJXREC' .AND. SE5->E5_TIPODOC $ "VL"
				dbSkip()
				Loop
			Case SE5->E5_TIPODOC $ "VLüBA/V2/CP"
				IF cModo == "R"
					If Alltrim(FunName()) $ "FINR340"  .And. cPaisLoc == "MEX"
						aRetorno[5]+=xMoeda(SE5->E5_VALOR,Val(SE5->E5_MOEDA),nMoeda,SE5->E5_DATA,,Iif(SE5->E5_TXMOEDA > 0,SE5->E5_TXMOEDA,))
					Else
						aRetorno[5]+=Iif(lNaoConv,SE5->E5_VALOR,xMoeda(SE5->E5_VLMOED2,nMoedaTit,nMoeda,SE5->E5_DATA,,Iif(SE5->E5_TXMOEDA > 0,SE5->E5_TXMOEDA,)))
					EndIf
					If SE5->E5_MOTBX == "CMP" .and. SUBSTR(SE5->E5_DOCUMEN,nTamTit,3) == MV_CRNEG  //NCC
						aRetorno[13]+=Iif(lNaoConv,SE5->E5_VALOR,xMoeda(SE5->E5_VALOR,nMoedaTit,nMoeda,SE5->E5_DATA,,Iif(SE5->E5_TXMOEDA > 0,SE5->E5_TXMOEDA,)))
						If _lImpComp
							//Retorno valores de Pis e Cofins para as compensacoes
							aRetorno[14]+= SE5->E5_VRETPIS
							aRetorno[15]+= SE5->E5_VRETCOF
							aRetorno[18]+= SE5->E5_VRETCSL
						Endif
					Endif
					//Retorno valor baixado via liquidacao
					If SE5->E5_MOTBX == "LIQ"
						aRetorno[19]+=Iif(lNaoConv,SE5->E5_VALOR,xMoeda(SE5->E5_VALOR,nMoedaTit,nMoeda,SE5->E5_DATA,,Iif(SE5->E5_TXMOEDA > 0,SE5->E5_TXMOEDA,)))
					Endif

					//Retorno valor baixado via Desdobramento com rastro
					If SE5->E5_MOTBX == "DSD" .and. _lRastro
						aRetorno[20]+=Iif(lNaoConv,SE5->E5_VALOR,xMoeda(SE5->E5_VALOR,nMoedaTit,nMoeda,SE5->E5_DATA,,Iif(SE5->E5_TXMOEDA > 0,SE5->E5_TXMOEDA,)))
					Endif
				Else
					//Baixa PA nao deve ser considerada
					If !(SE5->E5_TIPODOC == "BA" .and. SE5->E5_TIPO == "PA " .and. SE5->E5_RECPAG == "P" .and. SE5->E5_MOTBX <> "CMP")

						//Se nao converte
						If (lNaoConv .And. cPaisLoc == "BRA") .Or. (cPaisLoc <> "BRA" .And. nMoeda == nMoedaTit)
							aRetorno[6]+=	If(SE5->E5_TIPODOC == "BA" .and. SE5->E5_TIPO == "PA " .and. SE5->E5_RECPAG == "P" .and. SE5->E5_MOTBX <> "CMP",0,Iif(lNaoConv,SE5->E5_VALOR,xMoeda(Iif(cpaisLoc=="BRA",SE5->E5_VLMOED2,SE5->E5_VALOR),Iif(!Empty(Se5->E5_MOEDA).And. cPaisLoc<>"BRA",Val(SE5->E5_MOEDA),nMoedaTit),nMoeda,SE5->E5_DATA,,Iif(SE5->E5_TXMOEDA > 0,SE5->E5_TXMOEDA,))))
						Else
							//Se pais for Brasil ou
							// (Se a moeda do movimento estiver preenchida em outros paises ou
							//	 Se o registro for de compensacao
							//		(neste caso a moeda nao eh gravada e o valor na moeda do titulo esta no E5_VLMOED2)	)
							If cPaisLoc=="BRA" .Or. ;
								(( !Empty(Se5->E5_MOEDA) .OR. SE5->E5_MOTBX == 'CMP') .And. cPaisLoc<>"BRA" )
								nValor := SE5->E5_VLMOED2
							Else
								nValor := SE5->E5_VALOR
							Endif
							//Forço o valor para localização diferente de Brasil
							If cPaisLoc <> "BRA"
								nValor := SE5->E5_VALOR
							EndIf

							nMoedaCalc := IF(!Empty(Se5->E5_MOEDA).And. cPaisLoc<>"BRA",Val(SE5->E5_MOEDA),nMoedaTit)
							aRetorno[6]+= xMoeda(nValor,nMoedaCalc,nMoeda,SE5->E5_DATA)
	      			Endif
	            Endif

					If _lContrRet .And. _lPCCBaixa .And. (SE5->E5_PRETPIS $ " #3")
						aRetorno[12]+= SE5->(E5_VRETPIS+E5_VRETCOF+E5_VRETCSL)
					Endif
				Endif
				aRetorno[10]+= SE5->E5_VALOR
				aRetorno[11]+= 1   // Numero de baixas
				aRetorno[16] += SE5->E5_VLACRES
				aRetorno[17] += SE5->E5_VLDECRE

			Case SE5->E5_TIPODOC $ "DC/D2"
					aRetorno[2]+=Iif(lNaoConv,SE5->E5_VALOR,xMoeda(SE5->E5_VLMOED2,nMoedaTit,nMoeda,SE5->E5_DATA,Iif(SE5->E5_TXMOEDA > 0,SE5->E5_TXMOEDA,)))
			Case SE5->E5_TIPODOC $ "JR/J2"
					aRetorno[3]+=Iif(lNaoConv,SE5->E5_VALOR,xMoeda(Iif(cpaisLoc=="BRA",SE5->E5_VLMOED2,SE5->E5_VALOR),Iif(!Empty(Se5->E5_MOEDA).And. cPaisLoc<>"BRA",Val(SE5->E5_MOEDA),nMoedaTit),nMoeda,SE5->E5_DATA,,Iif(SE5->E5_TXMOEDA > 0,SE5->E5_TXMOEDA,)))
			Case SE5->E5_TIPODOC $ "MT/M2"
					aRetorno[4]+=Iif(lNaoConv,SE5->E5_VALOR,xMoeda(SE5->E5_VLMOED2,nMoedaTit,nMoeda,SE5->E5_DATA))
			Case SE5->E5_TIPODOC $ "CM/C2/CX"
					aRetorno[1]+=Iif(lNaoConv,SE5->E5_VALOR,xMoeda(Iif(cpaisLoc=="BRA",SE5->E5_VLMOED2,SE5->E5_VALOR),Iif(!Empty(Se5->E5_MOEDA) .And. cPaisLoc<>"BRA",Val(SE5->E5_MOEDA),nMoedaTit),nMoeda,SE5->E5_DATA,,Iif(SE5->E5_TXMOEDA > 0,SE5->E5_TXMOEDA,)))
			Case SE5->E5_TIPODOC $ "RA /"+MV_CRNEG
					aRetorno[7]+=Iif(lNaoConv,SE5->E5_VALOR,xMoeda(SE5->E5_VLMOED2,nMoedaTit,nMoeda,E5_DATA))
			Case (SE5->E5_TIPODOC = "PA" .Or. SE5->E5_TIPO = "PA") .or. SE5->E5_TIPODOC $ MV_CPNEG
					aRetorno[8]+=Iif(lNaoConv,SE5->E5_VALOR,xMoeda(Iif(cpaisLoc=="BRA",SE5->E5_VLMOED2,SE5->E5_VALOR),Iif(!Empty(Se5->E5_MOEDA) .And. cPaisLoc<>"BRA",Val(SE5->E5_MOEDA),nMoedaTit),nMoeda,E5_DATA,,Iif(SE5->E5_TXMOEDA > 0,SE5->E5_TXMOEDA,)))
			EndCase
			If ! Empty(SE5->E5_MOTBX )
				If SE5->E5_MOTBX == "NOR"
					aRetorno[9] := OemToAnsi( STR0008)			//"Normal"
				Elseif SE5->E5_MOTBX == "DEV"
					aRetorno[9] := OemToAnsi( STR0009)			//"Devolução"
				Elseif SE5->E5_MOTBX == "DAC"
					aRetorno[9] := OemToAnsi( STR0017) 			//"DAÇÃO"
				Elseif SE5->E5_MOTBX == "VEN"
					aRetorno[9] := OemToAnsi( STR0010)			//"VENDOR"
				Elseif SE5->E5_MOTBX == "CMP"
					aRetorno[9] := OemToAnsi( STR0011)			//"Compensação"
				Elseif SE5->E5_MOTBX == "CEC"
					aRetorno[9] := OemToAnsi( STR0012)			//"Comp Carteiras"
				Elseif SE5->E5_MOTBX == "DEB"
					aRetorno[9] := OemToAnsi( STR0013)			//"Débito C/C"
				Elseif SE5->E5_MOTBX == "LIQ"
					aRetorno[9] := OemToAnsi( STR0014)			//"Liquidação"
				Elseif SE5->E5_MOTBX == "FAT"
					aRetorno[9] := OemToAnsi( STR0015)			//"Faturado"
				Else
					IF (nT := ascan(aMotBaixas,{|x| x[1]= SE5->E5_MOTBX })) > 0
						aRetorno[9] := aMotBaixas [nT][2]
					Endif
				Endif
			Endif
			dbSkip()
		Enddo
	Endif
	dbSetOrder(nOrdem)
	dbSelectArea(cArea)
#IFDEF TOP
	EndIf
#Endif

RestArea(aArea)

Return(aRetorno)

//-----------------------------------------------------------------------------------------
// Funcoes retiradas do arquivo MATXFUNB.PRX
//-----------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FAJUROS

Calculo de juros.
Arquivo anterior: MATXFUNB.PRX

Parametros
ExpN1	: Valor do Titulo
ExpN2	: Saldo do Titulo a ser considerado Def.:E1_SALDO
ExpD3  	: Data de vencimento do Titulo.
ExpN4  	: Valor do Juros do Titulo
ExpN5  	: Taxa de Permanencia.
ExpN6  	: Moeda em que se encontra o Titulo
ExpD7  	: Data de Emissao.
ExpD8  	: Data de Baixa.


@Author	Eduardo Riera
@since	31/12/1999
/*/
//-----------------------------------------------------------------------------------------------------
Function faJuros(nVlrTit,nSaldo,dVencto,nValJur,nPerJur,nMoeda,dEmissao,dBaixa,nTxMoeda,dUltBaixa,dVencRea,cAliasSe1,cPrefixo,cNum,cParcela,cTipo,lRecalc,lLiquida)
Local aAreaSE1		:= {}
Local nAtraso		:= 0
Local nTxPer		:= 0
Local nJuros		:= 0
Local nAtrSimp		:= 0
Local nSaldoC		:= 0
Local cMvJurTipo	:= SuperGetMv("MV_JURTIPO",,"M")
Local nMVFINJRTP	:= SuperGetMv("MV_FINJRTP",,1)
Local nDiasAtraso	:= 0
// calculo juros do loja se TipoJur = L
Local lSE1 			:= .F.	 
Local lRestSE1 		:= .F.	

DEFAULT dUltBaixa 	:= dVencto
DEFAULT	cNum        := ""       	 
DEFAULT	cPrefixo  	:= ""			
DEFAULT	cParcela  	:= ""			
DEFAULT __lNewJuros	:= Existblock("NEWJUROS")
DEFAULT __lFJURREC	:= Existblock("FJURREC")
DEFAULT lRecalc		:= .T.
DEFAULT lLiquida	:= .F.
DEFAULT cAliasSe1	:= "SE1"
DEFAULT cTipo		:= (cAliasSe1)->E1_TIPO

If FwIsInCallStack('MaIntBxCr') .And. AllTrim( cTipo ) $ "RA" 
	Return nJuros
EndIf

//-------------------------------------------------------------------
// Se função que chamar a faJuros tiver posicionada no SE1         
// deverá passar apenas o ALIAS do SE1, caso contrário não         
// passar o alias e apenas a Chave do SE1 para o faJuros posicionar
//-------------------------------------------------------------------
nTxMoeda	:= If( nTxMoeda == Nil			, 0			, nTxMoeda										)
dBaixa		:= If( dBaixa == Nil			, dDataBase	, dBaixa										)
nVlrTit		:= If( nVlrTit == Nil			, nSaldo	, nVlrTit										)
dVencto		:= If( Day(dUltBaixa) == 0		, dVencto	, If(dUltBaixa > dVencto, dUltBaixa, dVencto)	)
dVencRea	:= If( dVencRea == Nil			, dVencto	, dVencRea										)
nAcresc		:= If( Type("nAcresc") != "N"	, 0			, nAcresc										)
nDecresc	:= If( Type("nDecresc") != "N"	, 0			, nDecresc										)

If ( DataValida(dVencto,.T.) >= dBaixa )
	dVencto := DataValida(dVencto,.T.)
EndIf

// Verifico se são as funções de Liquidação, pois 
// para a liquidação existe a baixa de um titulo porém
// ocorre a criação de novos titulos com datas de vencimentos
// futuras que necessita a cobraça de juros
If lLiquida
	nAtraso := dVencto - dBaixa
	cAliasSe1	:= ""
	If dVencRea <= dBaixa
		nAtraso := 0
	EndIf
Else
	nAtraso := dBaixa - dVencto
	//Se a data de pagamento for menor ou igual que o vencimento real nao calculo juros
	If dBaixa <= dVencRea
		nAtraso := 0	
	EndIf
EndIf

If ( Dow(dVencto) == 1 .Or. Dow(dVencto) == 7 )
	If Dow(dBaixa) == 2 .and. nAtraso <= 2
		nAtraso := 0
	EndIf
EndIf
If __lNewJuros
	nAtraso := Execblock("NEWJUROS",.f.,.f.,{dBaixa,dVencto,nAtraso})
Endif

nAtraso:=Iif(nAtraso<0,0,nAtraso)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Compara dias de atraso com o parametro tolerancia de atraso  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nAtraso <= SuperGetMv("MV_TOLER",,0)
	nAtraso := 0
EndIf

//Ponto de entrada para cálculo de juros
Default __lFJURCST := Existblock("FJURCST")
If !__lFJURCST
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Quando nÆo houver percentual de juros no t¡tulo deve-se cal- ³
	//³ cular pela taxa de permanencia. Quando ha percentual ou ele  ³
	//³ se refere a taxa de permanencia ou ele foi informado manual- ³
	//³ mente na inclusao do titulo a receber.							  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( nAtraso != 0 .And. (!Empty(nValJur) .Or. !Empty(nPerJur)) )
		If !Empty( nValJur ) .and. nMVFINJRTP == 1 		//  MV_FINJRTP = 1.Tx Perm
			nJuros := nValJur * nAtraso
		Else //MV_FINJRTP = 2.Juros ou 3.Ambos
			nTxPer := nPerJur
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calcula os juros compostos caso o parƒmetro seja "C";     ³
			//³ Calcula os juros simples caso o parametro seja "S"  ;     ³
			//³ Calcula os juros mistos  caso o parametro seja "M".       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cMvJurTipo == "M" .Or. cMvJurTipo == "S"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Calcula os juros simples											  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( cMvJurTipo == "M")
					nAtrSimp := If( nAtraso > 30 , 30 , nAtraso )
				Else
					nAtrSimp := nAtraso
				EndIf
				nJuros := nSaldo*(1+(nAtrSimp*(nTxPer/100)))
				nDiasAtraso := nAtraso
				nAtraso := Iif(cMvJurTipo == "M", nAtraso-30, nAtraso )
			EndIf
			If ( cMvJurTipo=="M" .And. nAtraso > 0 ) .Or. cMvJurTipo=="C"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Calcula os juros compostos										  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cMvJurTipo == "C"
					nSaldoC := nSaldo
				Else
					nSaldoC := nJuros
				EndIf
				nJuros := nSaldoC *( (1+( nTxPer/100 ) ) ** nAtraso )
			EndIf
			nJuros := nJuros - nSaldo  
			If nMVFINJRTP == 3 .and. !Empty( nValJur )  // MV_FINJRTP = 3.Ambos
				nJuros := nJuros + (nValJur * nDiasAtraso)
      	  EndIf
      	  	
      	  	//Integração TIN x PROTHEUS
      	  	If AllTrim(SE1->E1_ORIGEM) == "FINI055"
      	  		nTxPer := SE1->E1_VALJUR
     	  		If SuperGetMv("MV_JURTIN",,.F.)
					nJuros := (((nSaldo + nAcresc - nDecresc)*(1+(nAtrSimp*(nTxPer/100)))) - (nSaldo+ nAcresc - nDecresc))
					nMulta := (nPerJur/100) * (nSaldo + nAcresc - nDecresc)
      	  		Else
      	  			nJuros := ((nSaldo *(1+(nAtrSimp*(nTxPer/100)))) - nSaldo) + (nValJur * nDiasAtraso)
      	  			nMulta := (nPerJur/100) * nSaldo
      	  		EndIf
      	  	Endif
		EndIf
	EndIf
	
	//Calculo de Juros e Multas: SIGALOJA x SIGAFIN - Inicio 
	If cMvJurTipo == "L" .AND. lRecalc .and. !(cTipo $ MVRECANT+"|"+MV_CRNEG)    //Calculo de Juros e dias de atraso, segundo o controle de Lojas

		nJuros := 0

		If cAliasSE1 == "SE1" .AND. !Empty(cPrefixo+cNum+cParcela)
			aAreaSE1 := GetArea(cAliasSE1)  
			lRestSE1 := .T.
		    (cAliasSE1)->(dbSetOrder(1))   // E1_FILIAL+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO                                                                                                                  
			lSE1 := (cAliasSE1)->(MsSeek(xFilial(cAliasSe1)+cPrefixo+cNum+cParcela+cTipo)) 
		Else		
			lSE1 := !Empty(cAliasSE1) 				
		EndIf      

		If lSE1 
			//------------------------------------------------------- 
			// Calcula o Juros Função: LojxRJur - Lojxrec        
			//-------------------------------------------------------  
			//Caso o percentual de juros seja igual a zero, obtenho do parâmetro de % de juros do SigaLoja
			If Empty(nPerJur)
				nPerJur := SuperGetMV("MV_LJJUROS", NIL, 0)
			EndIf
		  	nJuros := LojxRJur( , ,nPerJur, nAtraso, (cAliasSe1)->E1_SALDO, (cAliasSe1)->E1_ACRESC, cAliasSe1, , (cAliasSe1)->E1_MOEDA, dBaixa,(cAliasSE1)->E1_VENCREA)   
		ElseIf lLiquida .AND. !lSE1
	  		nJuros := FinxRJur( nPerJur, nAtraso, nSaldo, nMoeda, dBaixa, dVencto )
		EndIf 
		
		If lRestSE1
			RestArea(aAreaSE1)
		EndIf 

	EndIf
	//Calculo de Juros e Multas: SIGALOJA x SIGAFIN  - Final
Else
	nJuros := Execblock("FJURCST",.f.,.f.,{dBaixa,dVencto,nAtraso,nValJur,nPerJur})
EndIf

// Ponto de entrada para recalculo do Juros
If __lFJURREC 
   nJuros := Execblock("FJURREC",.f.,.f.,{dBaixa,dVencto,nAtraso,nValJur,nPerJur,nJuros})
Endif
	
Return(nJuros)
//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FA070JUROS

Calculo de juros.
Arquivo anterior: MATXFUNB.PRX

@Param ExpN1	: Moeda
@Param ExpN2	: Valor do Titulo a ser considerado Def.:E1_SALDO
@Param dBaixa 	: Data em que o juros sera pago.
@Param nJuros 	: Valor do Juros do Titulo
@Param nTxMd	: Taxa da moeda

Observacao
Os parametros dBaixa e nJuros devem ser variaveis Privates
declaradas antes da chamada da funcao. E o titulo deve estar
posicionado. 															

@Author	Wagner Xavier
@since	06/05/1992
/*/
//-----------------------------------------------------------------------------------------------------
Function fa070Juros(nMoeda,nVlrTit,cAlias,dUltBaixa,nTxMd)
Local nTxMoeda
Local aArea    := GetArea()
Local aAreaSE1 := SE1->(GetArea())
Local aAreaSE5 := SE5->(GetArea())
Local nCalJur	 := 0

If cAlias == NIL
	cAlias := "SE1"
Endif

nMoeda := If(nMoeda==Nil,1,nMoeda)
nVlrTit:= If(nVlrTit==Nil,(cAlias)->E1_SALDO,nVlrTit)
dBaixa := If(Type("dBaixa")=="U",dDataBase,dBaixa)

If nTxMd == Nil
	nTxMoeda := If(cPaisLoc=="BRA",(cAlias)->E1_TXMOEDA,0)
Else
	nTxMoeda := nTxMd
EndIf

DEFAULT dUltBaixa := (cAlias)->E1_BAIXA

dbSelectArea("SE5")
dbSetOrder(7)//E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ
If dbSeek(xFilial("SE5")+(cAlias)->E1_PREFIXO+(cAlias)->E1_NUM+(cAlias)->E1_PARCELA+(cAlias)->E1_TIPO)
	If SE5->E5_MOTBX $ "CMP" //Se o título tiver sofrido compensação, considero a data de vencimento original e não a data da última baixa
		dUltBaixa := StoD("")
	EndIf
EndIf

//Calculo de Juros e Multas: SIGALOJA x SIGAFIN                 
nJuros := faJuros((cAlias)->E1_VALOR,nVlrTit,(cAlias)->E1_VENCTO,(cAlias)->E1_VALJUR,(cAlias)->E1_PORCJUR,(cAlias)->E1_MOEDA,(cAlias)->E1_EMISSAO,dBaixa,nTxMoeda,dUltBaixa,(cAlias)->E1_VENCREA ,cAlias, , , , )

//Aplica desconto nos juros do titulo
If (cAlias)->(FieldPos("E1_DESCJUR")) > 0
	If !Empty((cAlias)->E1_LIDESCF) .AND. (dBaixa <= (cAlias)->E1_LIDESCF)
		nJuros := nJuros - Round((((cAlias)->E1_DESCJUR / 100) * nJuros),2)
	EndIf
EndIf

// Converte o valor dos juros para moeda solicitada
nJuros := xMoeda(nJuros,(cAlias)->E1_MOEDA,nMoeda,dDataBase,,nTxMoeda)

//
// Template GEM
//
// Executa os calculos das variaveis private:
//		nCM1     
//		nProRata 
//		nMulta   
//		nJuros   
//
//
Default __lGEMJUROS  := ExistTemplate("GEMJUROS")
Default __lE1_NCONTR := ((cAlias)->(FieldPos("E1_NCONTR")) > 0)
If __lGEMJUROS .And. __lE1_NCONTR .And. !Empty((cAlias)->E1_NCONTR)
	ExecTemplate("GEMJUROS",.F.,.F.,{cAlias ,dBaixa ,dUltBaixa ,nVlrTit})
EndIf          

RestArea(aAreaSE5)
RestArea(aAreaSE1)
RestArea(aArea)
Return(nJuros)

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} GetNewLote

Retorna um codigo valido para novo lote (E5_LOTE)
Obs: Recomendado utilizar esta funcao apos validacao da CheckLote()

@Author	igor.nascimento
@since	14/06/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function GetNewLote()
Local cLote		:= ""
Local cQuery	:= ""
Local cTmpE5	:= GetNextAlias()

cQuery := "Select MAX(E5_LOTE) LOTE "
cQuery += "From " + RetSqlName("SE5") + " "
cQuery += "Where " 
cQuery += "E5_FILIAL = '" + xFilial("SE5") + "' And "
cQuery += "E5_SITUACA = '' And "
cQuery += "D_E_L_E_T_ = '' "
cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TCGenQry(,,cQuery),cTmpE5,.F.,.T.)
If Eof()
	cLote := StrZero( 1, TamSX3("EE_LOTE")[1] )
Else
	cLote := FinSomaLote((cTmpE5)->LOTE)		// Retorna um numero de lote valido
EndIf
(cTmpE5)->(dbCloseArea())
MsErase(cTmpE5)
Return cLote


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FxIniStat
Inicializa Staticas 

@Author	Mauricio Pequim Jr
@since	02/01/2017
/*/
//-----------------------------------------------------------------------------------------------------
Static Function FxIniStat()

If lFA070ADTSE5 == NIL
	lFA070ADTSE5	:= ExistBlock("FA070ADTSE5")
	lf70GrSe1 	:= Existblock("F70GRSE1")
	lF200GERA		:= Existblock("F200GERA")
	lF070CM		:= ExistBlock("F070CM")
	lF070GerAb	:= ExistBlock("F070GerAb")
	lFinSalTit	:= ExistBlock("FinSalTit")
	lF070GrvHis	:= ExistBlock("F070GrvHis")
	lFin70BxIr	:= ExistBlock("Fin70BxIr")
	lF070IRAB		:= ExistBlock("FIN70IRAB")
	lFA070ADTSE5	:= ExistBlock("FA070ADTSE5")
	lF070Imp2		:= ExistBlock("F070Imp2")
	lFa070Imp		:= ExistBlock("Fa070Imp")
	lF070HIST		:= ExistBlock("F070HIST")
	lFINAJURO		:= ExistBlock("FINAJURO")
	lF070DISS		:= ExistBlock("F070DISS")
	lSE3FI070		:= ExistBlock("SE3FI070")
	lSE3F070		:= ExistBlock("SE3F070")
	lF070MV1		:= ExistBlock("F070MV1")
	lF70E5ADT		:= ExistBlock("F70E5ADT")
	lSE5FI070		:= ExistBlock("SE5FI070")
	lF070VMOT		:= ExistBlock("F070VMOT")
	lFA070CMI		:= ExistBlock("FA070CMI")
Endif

Return lF070IRAB

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinFatAut

Geração de Fatura a Receber Automática

@Param aRec2Bx	: Array contendo os Recnos dos títulos a serem baixados
@Param aParcGer	: Array das Parcelas a serem Geradas 
				aParcGer [nX,1]  = Prefixo
				aParcGer [nX,2]  = Numero
				aParcGer [nX,3]  = Parcela
				aParcGer [nX,4]  = Tipo
				aParcGer [nX,5]  = Cliente
				aParcGer [nX,6]  = Loja
				aParcGer [nX,7]  = Natureza
				aParcGer [nX,9]  = Valor Bruto da Parcela
				aParcGer [nX,9]  = Decréscimo
				aParcGer [nX,10] = Data Vencto da Parcela 

@Author	Mauricio Pequim Junior
@since	09/04/2016
/*/
//-----------------------------------------------------------------------------------------------------

Function FinFatAut(aRec2Bx,aParcGer,aErroAuto)

Local lRet := .F.
Local aImpostos := Array(12)

If Len(aRec2Bx) > 0 .and.  Len(aParcGer) > 0  

	//Inicializa array dos impostos utilizado para geração das parcelas
	AFill( aImpostos, 0 ) 
	
	//Inicializa as variáveis staticas utilizadas na geração das parcelas
	FinIniVar()

	BEGIN TRANSACTION
	
	//Baixa os títulos da Fatura
	If FinFtBx(aRec2Bx,aImpostos,@aErroAuto)
	
		//Gera as Parcelas da Fatura
		lRet := FinFtGer(aParcGer,aImpostos,@aErroAuto)
		
	Endif
	
	END TRANSACTION
	
Endif

aImpostos := NIL

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinFtBx

Baixa dos titulos GERADORES da fatura

@Param aRec2Bx		: Array contendo os Recnos dos títulos a serem baixados
@Param aImpostos	: Array dos impostos e base a serem repassados para as Parcelas (total dos impostos)  
				aImpostos[01] = Base IRF
				aImpostos[02] = Valor IRF
				aImpostos[03] = Base INS
				aImpostos[04] = Valor INS
				aImpostos[05] = Base PIS
				aImpostos[06] = Valor PIS
				aImpostos[07] = Base COF
				aImpostos[08] = Valor COF
				aImpostos[09] = Base CSL
				aImpostos[10] = Valor CSL
				aImpostos[11] = Base ISS
				aImpostos[12] = Valor ISS

@Author	Mauricio Pequim Junior
@since	09/04/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function FinFtBx(aRec2Bx,aImpostos,aErroAuto)

Local nX 		:= 0
Local nLenBx	:= Len(aRec2Bx)
Local lRet		:= .T.
Local cFilAtu	:= cFilAnt
Local _aTit		:= {}

Private lMsHelpAuto := .T. 
Private lMsErroAuto := .F. 

Default aErroAuto := {}

FCadMotBx("BFT", Padr("BAIXA FAT.", 10), "ANNN") //Inclusao motivo de baixa

For nX := 1 to nLenBx

	//Posiciono a SE1 para Baixar
	SE1->(dbGoto(aRec2Bx[nX]))
	
	aImpostos[1]  += SE1->E1_BASEIRF
	aImpostos[2]  += SE1->E1_IRRF
	aImpostos[3]  += SE1->E1_BASEINS
	aImpostos[4]  += SE1->E1_INSS
	aImpostos[5]  += SE1->E1_BASEPIS
	aImpostos[6]  += SE1->E1_PIS
	aImpostos[7]  += SE1->E1_BASECOF
	aImpostos[8]  += SE1->E1_COFINS
	aImpostos[9]  += SE1->E1_BASECSL
	aImpostos[10] += SE1->E1_CSLL
	aImpostos[11] += SE1->E1_BASEISS
	aImpostos[12] += SE1->E1_ISS	
	
	//Baixa Titulos a Receber
	_aTit := {}
	
	cFilAnt := SE1->E1_FILORIG
	
	AADD(_aTit , {"E1_PREFIXO"	, SE1->E1_PREFIXO , Nil })
	AADD(_aTit , {"E1_NUM"    	, SE1->E1_NUM     , Nil })
	AADD(_aTit , {"E1_PARCELA"	, SE1->E1_PARCELA , Nil })
	AADD(_aTit , {"E1_TIPO"   	, SE1->E1_TIPO    , Nil })
	AADD(_aTit , {"E1_CLIENTE"	, SE1->E1_CLIENTE , Nil })
	AADD(_aTit , {"E1_LOJA"   	, SE1->E1_LOJA    , Nil })
	AADD(_aTit , {"AUTMOTBX"    , "BFT"           , Nil }) //Motivo de baixa
	AADD(_aTit , {"AUTDTBAIXA"  , dDataBase       , Nil }) //Data da baixa
	AADD(_aTit , {"AUTDTCREDITO", dDataBase       , Nil }) //Data do credito em conta corrente
	AADD(_aTit , {"AUTHIST"     , STR0025         , Nil }) //Historico da Baixa. STR0025: "Baixa de título gerador de fatura"
	
	//3 = Baixa de titulo
	MSExecAuto({|x, y| FINA070(x, y)}, _aTit, 3)
	
	If  lMsErroAuto
		lRet := .F.
		aErroAuto := GetAutoGRLog()
		MOSTRAERRO()
		DisarmTransaction()
	    Exit 
	EndIf
	
Next nX

cFilAnt := cFilAtu

Return lRet
	
//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinFtGer

Inclusão dos títulos gerados pela Fatura

@Param aParcGer	: Array das Parcelas a serem Geradas 
				aParcGer [nX,1]  = Prefixo
				aParcGer [nX,2]  = Numero
				aParcGer [nX,3]  = Parcela
				aParcGer [nX,4]  = Tipo
				aParcGer [nX,5]  = Cliente
				aParcGer [nX,6]  = Loja
				aParcGer [nX,7]  = Natureza
				aParcGer [nX,8]  = Valor Bruto da Parcela
				aParcGer [nX,9]  = Decréscimo
				aParcGer [nX,10] = Data Vencto da Parcela 
@Param aImpostos	: Array dos impostos e base a serem repassados para as Parcelas (total dos impostos)  
				aImpostos[01] = Base IRF
				aImpostos[02] = Valor IRF
				aImpostos[03] = Base INS
				aImpostos[04] = Valor INS
				aImpostos[05] = Base PIS
				aImpostos[06] = Valor PIS
				aImpostos[07] = Base COF
				aImpostos[08] = Valor COF
				aImpostos[09] = Base CSL
				aImpostos[10] = Valor CSL
				aImpostos[11] = Base ISS
				aImpostos[12] = Valor ISS

@Author	Mauricio Pequim Junior
@since	09/04/2016
/*/
//-----------------------------------------------------------------------------------------------------	
Function FinFtGer(aParcGer,aImpostos,aErroAuto)

Local lRet			:= .T.
Local nLenPc		:= Len(aParcGer)
Local cPrefixo		:= "" 
Local cNumero		:= ""
Local cParcela		:= "" 
Local cTipo			:= "" 
Local cCliente		:= ""
Local cLoja			:= ""
Local cNatureza		:= ""
Local dEmiss		:= ""
Local dVencto		:= ""
Local nX			:= 0
Local nTotalGer		:= 0
Local nValDup		:= 0
Local nProp			:= 0
Local nPis			:= 0
Local nCofins		:= 0 
Local nCsll			:= 0
Local nIrrf			:= 0
Local nInss			:= 0
Local nIss			:= 0
Local nBasePis		:= 0
Local nBaseCof		:= 0 
Local nBaseCsl		:= 0
Local nBaseIrf		:= 0
Local nBaseIns		:= 0
Local nBaseIss		:= 0
Local nTotPis		:= 0
Local nTotCof		:= 0 
Local nTotCsll		:= 0
Local nTotIrrf		:= 0
Local nTotInss		:= 0
Local nTotIss		:= 0
Local nTotBasePis	:= 0
Local nTotBaseCof	:= 0 
Local nTotBaseCsl	:= 0
Local nTotBaseIrf	:= 0
Local nTotBaseIns	:= 0
Local nTotBaseIss	:= 0
Local _aTit			:= {}

Private lMsHelpAuto := .T. 
Private lMsErroAuto := .F. 

Default aErroAuto := {}

//Obtenho o valor total a gerar
For nX := 1 to nLenPC
	nTotalGer += aParcGer[nX,8]
Next 

//Gero as parcelas
For nX := 1 to nLenPC

	SA1->(dbSeToRDER(1))
	SA1->(MsSeek(xFilial("SA1")+cCliente+cLoja))

	nValDup := aParcGer[nX,8] //Valor da Parcela
	nDecres := aParcGer[nX,9] //Valor do Decrescimo
	dVencto := aParcGer[nX,10] //Data de Vencimento da Parcela
		
	//Proporcionaliza impostos
	nProp := nValDup / nTotalGer

	If nX != nLenPC
		nBaseIrf	:= Round(NoRound(aImpostos[1]  * nProp,3),2)
		nIrrf 		:= Round(NoRound(aImpostos[2]  * nProp,3),2)
		nBaseIns	:= Round(NoRound(aImpostos[3]  * nProp,3),2)
		nInss 		:= Round(NoRound(aImpostos[4]  * nProp,3),2)
		nBasePis	:= Round(NoRound(aImpostos[5]  * nProp,3),2)
		nPis		:= Round(NoRound(aImpostos[6]  * nProp,3),2)
		nBaseCof	:= Round(NoRound(aImpostos[7]  * nProp,3),2)
		nCofins		:= Round(NoRound(aImpostos[8]  * nProp,3),2)
		nBaseCsl	:= Round(NoRound(aImpostos[9]  * nProp,3),2)
		nCsll 		:= Round(NoRound(aImpostos[10] * nProp,3),2)
		nBaseIss	:= Round(NoRound(aImpostos[11] * nProp,3),2)
		nIss		:= Round(NoRound(aImpostos[12] * nProp,3),2)

		nTotIrrf 	+= nIrrf
		nTotInss 	+= nInss
		nTotPis		+= nPis
		nTotCof		+= nCofins 
		nTotCsll 	+= nCsll
		nTotIss		+= nIss
		
		nTotBaseIrf	+= nBaseIrf
		nTotBaseIns	+= nBaseIns
		nTotBasePis	+= nBasePis
		nTotBaseCof	+= nBaseCof  
		nTotBaseCsl	+= nBaseCsl
		nTotBaseIss	+= nBaseIss
	Else
		nBaseIrf	:= aImpostos[1] - nTotBaseIrf
		nIrrf 		:= aImpostos[2] - nTotIrrf
		nBaseIns	:= aImpostos[3] - nTotBaseIns
		nInss 		:= aImpostos[4] - nTotInss
		nBasePis	:= aImpostos[5] - nTotBasePis
		nPis		:= aImpostos[6] - nTotPis
		nBaseCof	:= aImpostos[7] - nTotBaseCof
		nCofins		:= aImpostos[8] - nTotCof
		nBaseCsl	:= aImpostos[9] - nTotBaseCsl
		nCsll 		:= aImpostos[10] - nTotCsll
		nBaseIss	:= aImpostos[11] - nTotBaseIss
		nIss		:= aImpostos[12] - nTotIss
	Endif	 						

	//Gera o titulo
	_aTit := {}
	
	dEmiss := dDataBase
	If dVencto < dEmiss
		dVencto := dEmiss
	Endif				
	
	AADD(_aTit, {"E1_PREFIXO" , Padr(aParcGer[nX,1],nLenPref), NIL})
	AADD(_aTit, {"E1_NUM"     , Padr(aParcGer[nX,2],nLenNume), NIL})
	AADD(_aTit, {"E1_PARCELA" , Padr(aParcGer[nX,3],nLenParc), NIL})
	AADD(_aTit, {"E1_TIPO"    , Padr(aParcGer[nX,4],nLenTipo), NIL})
	AADD(_aTit, {"E1_CLIENTE" , Padr(aParcGer[nX,5],nLenClie), NIL})
	AADD(_aTit, {"E1_LOJA"    , Padr(aParcGer[nX,6],nLenLoja), NIL})
	AADD(_aTit, {"E1_NATUREZ" , Padr(aParcGer[nX,7],nLenNatu), NIL})
	AADD(_aTit, {"E1_VENCTO"  , dVencto                      , NIL})
	AADD(_aTit, {"E1_VENCREA" , DataValida(dVencto,.T.)      , NIL})
	AADD(_aTit, {"E1_VENCORI" , DataValida(dVencto,.T.)      , NIL})
	AADD(_aTit, {"E1_EMISSAO" , dEmiss                       , NIL})
	AADD(_aTit, {"E1_EMIS1"   , dEmiss                       , NIL})
	AADD(_aTit, {"E1_NOMCLI"  , SA1->A1_NREDUZ               , NIL})
	AADD(_aTit, {"E1_MOEDA"   , 1                            , NIL})
	AADD(_aTit, {"E1_VALOR"   , nValDup                      , NIL})
	AADD(_aTit, {"E1_SALDO"   , nValDup                      , NIL})
	AADD(_aTit, {"E1_VLCRUZ"  , nValDup                      , NIL})
	AADD(_aTit, {"E1_DECRESC" , nDecres                      , NIL})
	AADD(_aTit, {"E1_SDDECRE" , nDecres                      , NIL})
	AADD(_aTit, {"E1_ORIGEM"  , "FINI791"                    , NIL})
	AADD(_aTit, {"E1_IRRF"    , nIrrf                        , NIL})
	AADD(_aTit, {"E1_INSS"    , nInss                        , NIL})
	AADD(_aTit, {"E1_PIS"     , nPis                         , NIL})
	AADD(_aTit, {"E1_COFINS"  , nCofins                      , NIL}) 
	AADD(_aTit, {"E1_CSLL"    , nCsll                        , NIL})
	AADD(_aTit, {"E1_ISS"     , nIss                         , NIL})
	AADD(_aTit, {"E1_BASEIRF" , nBaseIrf                     , NIL})
	AADD(_aTit, {"E1_BASEINS" , nBaseIns                     , NIL})
	AADD(_aTit, {"E1_BASEPIS" , nBasePis                     , NIL})
	AADD(_aTit, {"E1_BASECOF" , nBaseCof                     , NIL})
	AADD(_aTit, {"E1_BASECSL" , nBaseCsl                     , NIL})
	AADD(_aTit, {"E1_BASEISS" , nBaseIss                     , NIL})

	MSExecAuto({|x, y| FINA040(x, y)}, _aTit, 3)
  
	//Verifica se a gravacao ocorreu normalmente, e possibilita o uso do PE FA280
	//para complementar a gravacao.
	If  lMsErroAuto
	    aErroAuto := GetAutoGRLog()
	    MOSTRAERRO()
	    DisarmTransaction()
	    lRet := .F.
	Endif

Next
	
Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FinIniVar

Inicializa Staticas da Geração de Fatura a Receber Automática

@Author	Mauricio Pequim Junior
@since	09/04/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function FinIniVar()

If !_lIniVar
	nLenPref := TamSx3("E1_PREFIXO")[1]
	nLenNume := TamSx3("E1_NUM")[1] 
	nLenParc := TamSx3("E1_PARCELA")[1]
	nLenTipo := TamSx3("E1_TIPO")[1]
	nLenClie := TamSx3("E1_CLIENTE")[1]
	nLenLoja := TamSx3("E1_LOJA")[1]
	nLenNatu := TamSx3("E1_NATUREZ")[1]
	_lIniVar := .T.
Endif

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FCadMotBx
Efetua a insercao de motivos de baixa no arquivo SIGAADV.MOT                       
@param cMot, Motivo da baixa
@param cNomMot, Descricao do motivo da baixa
@param cConfMot, Configuracoes do motivo da baixa

@author  Totvs
@version P12.7
@since   14/09/2016
@return  Nil                                                                  
/*/
//-----------------------------------------------------------------------------------------------------
Static Function FCadMotBx(cMot, cNomMot, cConfMot)
	Local lMotBxEsp	:= .F.
	Local aMotbx 	:= ReadMotBx(@lMotBxEsp)
	Local nHdlMot 	:= 0 
	Local nI 		:= 0
	Local cFile 	:= "SIGAADV.MOT"
	Local nTamLn	:= 19

	If lMotBxEsp
		nTamLn	:= 20
		cConfMot	:= cConfMot + "N"
	EndIf
	If ExistBlock("FILEMOT")
		cFile := ExecBlock("FILEMOT",.F.,.F.,{cFile})
	Endif
		
	If Ascan(aMotbx, {|x| Substr(x,1,3) == Upper(cMot)}) < 1
		nHdlMot := FOPEN(cFile,FO_READWRITE)
		If nHdlMot <0
			HELP(" ",1,"SIGAADV.MOT")
			Final("SIGAADV.MOT")
		Endif
		
		nTamArq := FSEEK(nHdlMot,0,2) //VerIfica tamanho do arquivo
		FSEEK(nHdlMot,0,0) //Volta para inicio do arquivo
	
		For nI := 0 To nTamArq step nTamLn //Processo para ir para o final do arquivo	
			xBuffer := Space(nTamLn)
			FREAD(nHdlMot,@xBuffer,nTamLn)
	    Next nI
		
		fWrite(nHdlMot,cMot+cNomMot+cConfMot+chr(13)+chr(10))	
		fClose(nHdlMot)		
	EndIf
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc}PosicMov
Posiciona no movimento da carteira P ou R para gerar a seq de baixa correta. E no cancelamento 
para não trazer mov. da carteira contrária quando o título possui  mesma chave
@author Sivaldo Santos Oliveira
@since  15/02/2017
@version 12
/*/ 
//-----------------------------------------------------------------------------------------------------
Function PosicMov(cChave, cCart)
While SE5->(!Eof()) .And. cChave == SE5->(E5_FILIAL+E5_TIPODOC+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO)+Dtos(SE5->E5_DATA)+SE5->(E5_CLIFOR+E5_LOJA+E5_SEQ)  
	If cCart == SE5->E5_RECPAG
		Exit
	Else
		SE5->(Dbskip())	
	EndIf
EndDo
Return Nil

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} IDProcFinXFun()
Retorna o ID da procedures que dá sADMINuporte às funções desta rotina
@type function
@author NORBERTOM
@since 22/02/2017
@version 1.0
@return cIDProc, Caracter, Versão da procedure que auporte a rotina FINXFUN
@example
cIDProcFinXFun := IDProcFinXFun()
/*/
//-----------------------------------------------------------------------------------------------------
FUNCTION IDProcFinXFun()
RETURN VerIDProc()

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³VerIDProc ³ Autor ³ Marcelo Pimentel      ³ Data ³24.07.2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Identifica a sequencia de controle do fonte ADVPL com a     ³±±
±±³          ³stored procedure, qualquer alteracao que envolva diretamente³±±
±±³          ³a stored procedure a variavel sera incrementada.            ³±±
±±³          ³Procedure FIN002                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/         
Static Function VerIDProc()
Return '010'

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FAValAces

Calculo de valores acessórios (versão básica)

@Author	Mauricio Pequim Jr
@since	20/08/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FAValAces(cPrefixo,cNum,cParcela,cTipo,cCliFor,cLoja,cNatureza, lBaixados,cCodVa)

Local nTotVlAces	:= 0
Local cQuery		:= ""
Local cChaveTit		:= ""
Local cChaveFK7		:= ""
Local aArea			:= GetArea()

DEFAULT cPrefixo	:= ""
DEFAULT cNum		:= ""
DEFAULT cParcela	:= ""
DEFAULT cTipo		:= ""
DEFAULT cCliFor		:= ""
DEFAULT cLoja		:= ""
DEFAULT cNatureza	:= ""
Default lBaixados 	:= .F.
Default cCodVa		:= ""

If TableInDic('FKD')
	If !Empty(cNum) 
		//Apenas titulos de INSS e IRRF terão seus valores acessórios verificados
		If FaPodeTVA(cTipo,cNatureza,.F.,"P") 
	
			//Dados da tabela auxiliar com o código do título a pagar
			cChaveTit := xFilial("SE2") + "|" + cPrefixo + "|" + cNum + "|" + cParcela + "|" + cTipo + "|" + cCliFor + "|" + cLoja
			cChaveFK7 := FINGRVFK7("SE2", cChaveTit)
			
			If lBaixados
				cQuery := "SELECT SUM(FKD_VLCALC) TOTSLDVA FROM " + RetSQLName("FKD") 			
			Else
				cQuery := "SELECT SUM(FKD_SALDO) TOTSLDVA FROM " + RetSQLName("FKD") 
			EndIf
			cQuery += " WHERE  FKD_FILIAL = '" + FWxFilial("FKD") + "'"
			cQuery += " AND FKD_IDDOC = '" + cChaveFK7 + "'" 
	
			//Monta o IN para seleção de códigos de Valores Acessórios específicos		
			If !Empty(cCodVa)
				cQuery += " AND FKD_CODIGO IN " + FormatIn(cCodVa,"|")
			Endif
			 
			cQuery += " AND D_E_L_E_T_ <> '*' "		
			cQuery := ChangeQuery( cQuery )
			
			cAliasQry := GetNextAlias()
			dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )
			If ( cAliasQry )->( !EOF() )
				nTotVlAces := ( cAliasQry )->TOTSLDVA
			Endif
			( cAliasQry )->( DbCloseArea() )
	 
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return nTotVlAces

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FAPodeTVA

Valida se o título pode ter valores acessórios (versão básica)

@Author	Mauricio Pequim Jr
@since	20/08/2015
/*/
//-----------------------------------------------------------------------------------------------------
Function FAPodeTVA(cTipo,cNatureza,lHelp,cCarteira) 

Local lRet := .F.

DEFAULT cTipo 		:= ""
DEFAULT cNatureza	:= ""
DEFAULT lHelp		:= .F.
DEFAULT cCarteira	:= "P"

If cCarteira == "P"

	If nTamNat == NIL
		nTamNat := TamSx3("E2_NATUREZ")[1]
	Endif

	If cNatIRF == NIL
		cNatIRF := PADR(&(SuperGetMv("MV_IRF")),nTamNat)		
	Endif
	
	cNatureza := PadR(cNatureza,nTamNat)
	
	If cTipo == "INS" .or. (cTipo == "TX " .and. cNatureza == cNatIrf)
		lRet := .T.
	Else
		lRet := .F.
		If lHelp
			Help(,,"FVATIPO",,STR0022,1,0)	//"Apenas títulos de IRRF e INSS poderão ter valores acessórios vinculados."
		Endif	
	EndIf
	
Else

	If cTipo $ MVPROVIS+"/"+MVRECANT+"/"+MV_CRNEG+"/"+MVABATIM+"/"+MVPAGANT+"/"+MV_CPNEG
		lRet 	:= .F.
		If lHelp
   	   		Help(,,"FVATIPO1",,STR0026,1,0)	//"Esse tipo de titulo não pode ter valores acessórios."
   	   	Endif	   	   	
   	Else
   		lRet	:=	.T.
	Endif

EndIf

Return lRet

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FSetFK6FKD
Insere os Novos Valores Acessorios (FKD) no submodel de valores acessórios (FK6)

@author Mauricio Pequim Jr
@since  24/08/2015
@version P12
/*/
//-----------------------------------------------------------------------------------------------------
Function FSetFK6FKD(oSubFK6,cChaveFK7,cIdFK,cCart)
Local aArea		:= GetArea()
Local cTabOri	:= ""	
Local nValCalc	:= 0	
Local nValInfo	:= 0
Local cPeriodo	:= ""
Local lGrvFk6 	:= .T.

DEFAULT oSubFK6	:= NIL
DEFAULT cChaveFK7	:= ""
DEFAULT cIdFK		:= ""
DEFAULT cCart		:= "P"

cTabOri := If(cCart == "R", "FK1","FK2")

If TableInDic('FKD')
	FKD->(DBSETORDER(2)) //FKD_FILIAL + FKD_IDDOC + FKD_CODIGO
	If FKD->(DBSeek(xFilial("FKD")+cChaveFK7))
	
		While xFilial("FKD") + cChaveFK7 == FKD->(FKD_FILIAL + FKD_IDDOC)
			If Type("lF070Auto") == 'L' .And. lF070Auto
				cPeriodo := Posicione( "FKC", 1, FWxFilial("FKC") + FKD->FKD_CODIGO, "FKC_PERIOD" )			
				If cPeriodo == "1" .And. ! Empty(FKD->FKD_DTBAIX) //Se o VA de período único já foi baixado, então não grava novamente na FK6
					lGrvFk6 := .F.
				Else
					lGrvFk6 := .T.
				EndIf
			Else
				lGrvFk6 := .T.
			Endif
			
			If lGrvFk6
				nValInfo := If(cCart == "P", FKD->FKD_VLCALC , FKD->FKD_VLINFO) 
				nValCalc := If(cCart == "P", FKD->FKD_VALOR  , FKD->FKD_VLCALC)
				
				If nValInfo != 0 .or. nValCalc != 0
					//Grava Valores Acessorios (juros, multas, descontos etc)
					If !oSubFK6:IsEmpty()
						//Inclui a quantidade de linhas necessárias
						oSubFK6:AddLine()		
					
						//Vai para linha criada
						oSubFK6:GoLine( oSubFK6:Length() )
					EndIf	
					oSubFK6:SetValue( "FK6_VALMOV" , nValInfo )
					oSubFK6:SetValue( "FK6_VALCAL" , nValCalc )
					oSubFK6:SetValue( "FK6_TPDESC" , "2" )
					oSubFK6:SetValue( "FK6_TPDOC"  , "VA" )
					oSubFK6:SetValue( "FK6_RECPAG" , cCart )
					oSubFK6:SetValue( "FK6_TABORI" , cTabOri )
					oSubFK6:SetValue( "FK6_IDORIG" , cIdFK )
					oSubFK6:SetValue( "FK6_HISTOR" , FGetFKCDesc(FKD->FKD_CODIGO) )
					oSubFK6:SetValue( "FK6_CODVAL" , FKD->FKD_CODIGO )
					oSubFK6:SetValue( "FK6_ACAO"   , "1" )	
				EndIf
			
			Endif
				
			FKD->(dbSkip())
		EndDo
	EndIf
EndIf
		
RestArea(aArea)

aSize ( aArea, 0 )
aArea := Nil

Return .T.

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FGetFKCDesc
Obtém a descrição do valor acessório

@author Mauricio Pequim Jr
@since  24/08/2015
@version P12
/*/
//-----------------------------------------------------------------------------------------------------
Function FGetFKCDesc(cCodigo)

Local cRet := ""

FKC->(DBSetOrder(1))
If FKC->(MsSeek(xFilial("FKC")+cCodigo))
	cRet := FKC->FKC_DESC
Endif

Return cRet	

//-----------------------------------------------------------------------------------------------------	
/*/{Protheus.doc} FinGrvFI2
Função de gravação da tabela FI2 - Ocorrencias CNAB.
@example
	aItemsFI2[x][1]: Ocorrencia                         
	aItemsFI2[x][2]: Titulo do campo 
	aItemsFI2[x][3]: Valor anterior
	aItemsFI2[x][4]: Novo valor    
	aItemsFI2[x][5]: Nome do campo 
	aItemsFI2[x][6]: Tipo do campo 
@author Bruno Sobieski
@since  03/02/2005
/*/
//-----------------------------------------------------------------------------------------------------
Function FinGrvFI2()
Local nX		:=	1
Local aArea 	:= GetArea()
Local cChave 	:= ''
Local lF040GRCOM:= ExistBlock("F040GRCOM")

	lSubstFI2	:=	IIf(Type("lSubstFI2")=="L",lSubstFI2,.T.)
	
	FI2->(DbSetOrder(1))
	If Type('aItemsFI2') == "A" .And. !Empty(aItemsFI2)
		
		For nX := 1 To Len(aItemsFI2)
			
			If !Empty(aItemsFI2[nX][1])
	
				cChave	:=	xFilial("FI2",SE1->E1_FILORIG) + "1" + SE1->(E1_NUMBOR + E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO +;
				 								   E1_CLIENTE + E1_LOJA) + aItemsFI2[nX][1] + "2"
				
				// Pesquisa pela ocorrencia nao gerada (FI2_GERADO = 2 - Ja esta na chave)
				If lSubstFI2 .And. FI2->(DbSeek(cChave))
					RecLock('FI2',.F.)			
				Else			
					RecLock('FI2',.T.)			
				Endif	
				Replace FI2_FILIAL 	WITH xFilial("FI2",SE1->E1_FILORIG)
				Replace FI2_CARTEI 	WITH "1"
				Replace FI2_OCORR  	WITH aItemsFI2[nX][1]
				Replace FI2_GERADO 	WITH "2"
				Replace FI2_NUMBOR 	WITH SE1->E1_NUMBOR
				Replace FI2_PREFIX	WITH SE1->E1_PREFIXO
				Replace FI2_TITULO	WITH SE1->E1_NUM
				Replace FI2_PARCEL	WITH SE1->E1_PARCELA
				Replace FI2_TIPO  	WITH SE1->E1_TIPO   
				Replace FI2_CODCLI	WITH SE1->E1_CLIENTE
				Replace FI2_LOJCLI	WITH SE1->E1_LOJA
				Replace FI2_DTOCOR	WITH dDataBase               
				Replace FI2_DESCOC 	WITH Posicione('SEB',1,xFilial('SEB',SE1->E1_FILORIG)+SE1->E1_PORTADO+Pad(FI2->FI2_OCORR,;
										 Len(SEB->EB_REFBAN))+"E","SEB->EB_DESCRI")
				Replace FI2_VALANT	WITH aItemsFI2[nX][3]
				Replace FI2_VALNOV	WITH aItemsFI2[nX][4]
				Replace FI2_CAMPO 	WITH aItemsFI2[nX][5]
				Replace FI2_TIPCPO	WITH aItemsFI2[nX][6]
				MsUnLock()     
				
				IF lF040GRCOM
					ExecBlock( "F040GRCOM", .F., .F., {aItemsFI2} ) 
			    Endif
				
			Endif
		Next nX
	EndIf
		
	RestArea(aArea)

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} F070InsCob
Geração de instrução de cobrança.
@author William Gundim
@since  11/03/2016
@version P12.1.7
/*/
//-----------------------------------------------------------------------------------------------------
Function FxBInsCob(lManual,cInsc,lRest)
Local lInsCob		:= .F.
Local aArea			:= {}
Local aAux			:= {}
Local lRet			:= .T.
Private aItemsFI2	:= {}
Default lManual		:= .F.
Default cInsc		:= '1'
Default lRest		:= .F.
	
	lInsCob	:= SuperGetMv("MV_INSCOB",,"0") $ cInsc
	//
	If lInsCob
		//__nMsgIns 1 - Em lote, 2 - Em Lote confirmada, 3 - Em lote cancelado.
		If __nMsgIns == 1 .AND. !IsBlind() .AND. !lManual 
			If MsgYesNo(STR0023,'')
				__nMsgIns := 2
			Else
				__nMsgIns := 3	
			EndIf
		EndIf
		//
		If __nMsgIns != 3
			aArea	:= GetArea()
			aSize(aAux, 6)
			//
			If !(SE1->E1_TIPO $ MVRECANT+"/"+MVABATIM+"/"+MVPROVIS) .AND. !Empty(SE1->E1_IDCNAB) .AND. !Empty(SE1->E1_NUMBOR) .AND. SE1->E1_SITUACA $ FN022LSTCB(3)
				If lManual .AND. !IsBlind()
				  lRet := MsgYesNo(STR0024,'')
				EndIf
				If lRet
					aAux[1] := '02'
					aAdd(aItemsFI2,aAux) 
					FinGrvFI2()
				EndIf
			EndIf
			RestArea(aArea)
			aSize(aAux, 0)
		EndIf
	EndIf	
	
	If lRest
		__nMsgIns := 1 //Restaura o valor da variavel static.
	EndIf
	
Return 

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FxBDelFI2
Exclusão da FI2.
@author William Gundim
@since  15/03/2016
@version P12.1.7
/*/
//-----------------------------------------------------------------------------------------------------
Function FxBDelFI2()
Local aArea	:= GetArea()

	dbSelectArea('FI2')
	FI2->(dbSetOrder(1))
	If FI2->(dbSeek( xFilial('FI2',SE1->E1_FILORIG) + '1' + SE1->(E1_NUMBOR + E1_PREFIXO + E1_NUM +	 E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA + '02' + '2')))
	
		Reclock("FI2",.F.)
		FI2->(DbDelete())
		FI2->(MsUnlock())
		
	EndIf
	
	RestArea(aArea)
	
Return 

//-----------------------------------------------------------------------------------------------------
// Funções implementadas para cálculo de valores acessórios
//-----------------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FValAcess

Calculo de valores acessórios (versão completa)

@Author Simone Mie Sato Kakinoana
@since	13/07/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function FValAcess(cPrefixo,cNum,cParcela,cTipo,cCliFor,cLoja,cNatureza, lBaixados,cCodVa,cCarteira,dDtBaixa,aValAces,nMoedaTit,nMoedaBco,nTxMoeda)
Local aArea		:= GetArea()
Local nVlAces		:= 0
Local nTotVlAces	:= 0
Local nSaldo		:= 0 
Local cQuery		:= ""
Local cChaveTit	:= ""
Local cChaveFK7	:= ""
Local cFilOriTit	:= ""
Local cFilOriFKC	:= ""

DEFAULT cPrefixo	:= ""
DEFAULT cNum		:= ""
DEFAULT cParcela	:= ""
DEFAULT cTipo		:= ""
DEFAULT cCliFor	:= ""
DEFAULT cLoja		:= ""
DEFAULT cNatureza	:= ""
DEFAULT lBaixados	:= .F.
DEFAULT cCodVa	:= ""
DEFAULT cCarteira	:= "R"
DEFAULT dDtBaixa	:= dDataBase
DEFAULT aValAces	:= {}
DEFAULT nMoedaTit	:= SE1->E1_MOEDA
DEFAULT nMoedaBco	:= 1
DEFAULT nTxMoeda	:= RecMoeda(dDtBaixa,nMoedaTit)

If TableInDic('FKD')

	If !Empty(cNum)
		//Verifica se o título pode ter valores acessórios
		If FaPodeTVA(cTipo,cNatureza,.F.,cCarteira) 
			
			If cCarteira == "P"
				cFilOriTit := FWxFilial( "SE2", SE2->E2_FILORIG )
				cFilOriFKC := FWxFilial( "FKC", SE2->E2_FILORIG )
				cChaveTit := cFilOriTit + "|" + cPrefixo + "|" + cNum + "|" + cParcela + "|" + cTipo + "|" + cCliFor + "|" + cLoja
				cChaveFK7 := FINGRVFK7( "SE2", cChaveTit )
				nSaldo := SE2->E2_SALDO
			Else
				cFilOriTit := FWxFilial( "SE1", SE1->E1_FILORIG )
				cFilOriFKC := FWxFilial( "FKC", SE1->E1_FILORIG )
				cChaveTit := cFilOriTit + "|" + cPrefixo + "|" + cNum + "|" + cParcela + "|" + cTipo + "|" + cCliFor + "|" + cLoja
				cChaveFK7 := FINGRVFK7( "SE1", cChaveTit )
				nSaldo := SE1->E1_SALDO		
			EndIf						
			
			dbSelectArea("FKD")
			FKD->( dbSetOrder(2) ) //FKD_FILIAL+FKD_IDDOC+FKD_CODIGO
			If FKD->( msSeek( cFilOriTit + cChaveFK7 + cCodVa ) )
				While FKD->( !Eof() ) .And. FKD->FKD_FILIAL == cFilOriTit .And. FKD->FKD_IDDOC == cChaveFK7
					FKC->( dbSetOrder(1) ) //FKC_FILIAL+FKC_CODIGO
					If FKC->( msSeek( cFilOriFKC + FKD->FKD_CODIGO ) )
						If FKC->FKC_ATIVO == "1"
						
							nVlAces := FCalcVA(cCarteira,dDtBaixa,nSaldo)
							
							//Converte os valores para a moeda corrente do pais
							If nMoedaTit > 1 .and. nMoedaTit != nMoedaBco
								nVlAces := xMoeda(nVlAces,nMoedaTit,nMoedaBco,dDtBaixa,3,,nTxMoeda)
							Endif
							
							//Gravo o valor calculado e o valor informado para que gravações da FK6 
							RecLock("FKD")
							FKD->FKD_VLCALC := nVlAces
							FKD->FKD_VLINFO := nVlAces
							FKD->(MSUnlock())
							
							AADD(aValAces, {cChaveFK7,FKD->FKD_CODIGO,nVlAces})
							
							//Somo Total de VA				
							nTotVlAces	+= nVlAces
						EndIf
						//Quando enviado um código específico, saio do While
						If !Empty(cCodVa)
							Exit
						Endif
					EndIf
					FKD->(dbSkip())
				End
			EndIf
		EndIf
	EndIf	
EndIf

RestArea(aArea)

Return nTotVlAces

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FCalcVA

Efetua o calculo dos valores acessorios,conforme regra cadastrada.

@Author	Simone Mie Sato Kakinoana
@since	14/07/2016
/*/
//-----------------------------------------------------------------------------------------------------
Function FCalcVA(cCarteira,dDtBaixa,nSaldo)

Local nSaldoVA		:= 0
Local nValor		:= 0
Local nDias			:= 0
Local nFator		:= 0  

Local dVencto		:= Iif(cCarteira == "P",SE2->E2_VENCTO,SE1->E1_VENCTO)
Local dVencrea		:= Iif(cCarteira == "P",SE2->E2_VENCREA,SE1->E1_VENCREA)
Local dEmissao		:= Iif(cCarteira == "P",SE2->E2_EMISSAO,SE1->E1_EMISSAO)

Local lCalcula		:= .T.

If TableInDic('FKD')

	nSaldoVA := FKD->FKD_SALDO
	
	dDtBaixa	:= Iif(Empty(dDtBaixa),dDataBase,dDtBaixa)
	
	If ( cCarteira == "P" .And.  FKC->FKC_RECPAG == "2" ) .Or. ( cCarteira == "R" .And.  FKC->FKC_RECPAG =="1" )
		lCalcula	:= .F.
	EndIf
	
	If lCalcula
	
		//Para verificar se os valores acessórios devem ser calculados, verifica pela data de vencimento real.
		If FKC->FKC_APLIC == "1" 		//Até a data de vencimento
			If dDtBaixa > dVencrea - FKC->FKC_NDIAS
				lCalcula		:= .F.
			EndIf
		ElseIf FKC->FKC_APLIC == "2"		//Após o vencimento
			If dDtBaixa <= dVencrea	+ FKC->FKC_NDIAS	 
				lCalcula		:= .F.
			EndIf
		Endif
	 	
		If lCalcula
		
			//Cálculo do número de dias
			//Para verificar o número de dias, deve-se considerar a data de vencimento.
			If Empty(FKD->FKD_DTBAIX) //Ainda não houve baixa
				If FKC->FKC_PERIOD == "1" //Se o periodo for unico
					nDias	:= 1
				Else			
					If FKC->FKC_APLIC == "1"	 //Ate a data de vencimento, periodo é calculado: database - data de emissão
						nDias	:= dDtBaixa - dEmissao 			
					ElseIf FKC->FKC_APLIC == "2" //Apos a data de vencimento, periodo é calculado: database - data de vencimento do titulo
						nDias	:= dDtBaixa - dVencto
					ElseIf FKC->FKC_APLIC == "3" //Sempre
						nDias	:= dDtBaixa - dEmissao 			
					EndIf				
					
					If nDias < 0 
						nDias := 0
					EndIf				
				EndIf	
			Else	//Houve baixa parcial
				If FKC->FKC_PERIOD == "1" //Se o periodo for unico, não calcula o VA novamente, pois já houve baixa parcial. 
					nDias	:= 0
				Else	 					 
					If FKC->FKC_APLIC == "1"			//Ate a data de vencimento, periodo é calculado: FKD_DTBAIX - database				
						nDias	:= dDtBaixa - FKD->FKD_DTBAIX 			
					ElseIf FKC->FKC_APLIC == "2"		//Apos a data de vencimento, periodo é calculado: FKD_DTBAIX - data de vencimento do titulo
						nDias	:= dDtBaixa - FKD->FKD_DTBAIX			
					ElseIf FKC->FKC_APLIC == "3"		//Sempre
						nDias	:= dDtBaixa - FKD->FKD_DTBAIX 			
					EndIf							
				EndIf
			EndIf		
			
			If FKC->FKC_PERIOD $ "1/2"		//Se o período for único ou diário
				nFator	:= 1
			ElseIf FKC->FKC_PERIOD == "3"	//Mensal
				nFator	:= 30
			ElseIf FKC->FKC_PERIOD == "4"	//Anual
				nFator := 360
			EndIf
			
			If FKC->FKC_ACAO == "1" //Se soma
						
				If FKC->FKC_TPVAL == "1" //Se for percentual
					nValor +=  ( ( nSaldo * ( FKD->FKD_VALOR/100 )) / nFator )   * nDias 
				Else //Se for valor
					nValor	+=  ( FKD->FKD_VALOR / nFator)   * nDias 
				EndIf 
			Else //Subtrai
				If FKC->FKC_TPVAL == "1" //Se for percentual
					nValor -=  ( ( nSaldo * ( FKD->FKD_VALOR/100 )) / nFator ) * nDias			
				Else //Se for valor
					nValor	-=  ( FKD->FKD_VALOR / nFator)   * nDias 	 			
				EndIf
			EndIf
			
			//Trata o campo regra do VA
			If !Empty(FKC->FKC_REGRA)
				If FKC->FKC_ACAO == "1"		//Se soma
					nValor += &(FKC->FKC_REGRA)
				Else
					nValor -= &(FKC->FKC_REGRA)			
				EndIf		
			EndIF 	
		EndIf
		
	EndIf

EndIf

Return(nValor)

//-------------------------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FxLoadFK6
Função Responsavel por carregar a tabela FK6 e retorna-la no Vetor os dados somados dos campos FK6_VALCAL,FK6_VALMOV
@author jose.aribeiro
@since 04/08/2016
@version undefined
@param cTabOri , caracters, A Tabela de Origem do Dado (Obrigatorio)
@param cIdOrig , caracters, ID da Origem do Dado (Obrigatorio)
@param cTipo   , caracters, Tipodoc específico ( (JR, MT, DC, VA) (Opcional)
@return aRet   , Array    , Vetor com as somatorias dos campos FK6_VALCAL,FK6_VALMOV, sendo o vetor composto na mesma ordem 
@example
FxLoadFK6("FK2","71297d3eb68640009595d22036c1b852")
/*/
//-------------------------------------------------------------------------------------------------------------------------------
Function FxLoadFK6(cTabOri,cIdOrig,cTipo)
Local aRet		:= {}
Local nValCal	:= 0
Local nValMov	:= 0
Local aArea		:= GetArea()
Local aAreaFK6	:= FK6->(GetArea())
Local aAreaFk2	:= FK2->(GetArea())
Local lVerTipo	:= .F.

Default cTipo	:= "" 

If TableInDic('FKD')
	//Caso esteja vendo um tipo específico de valor acessório (JR, MT, DC, VA)
	If !Empty(cTipo)
		lVerTipo := .T.
	Endif

	If(cTabOri == "FK1")
		DbSelectArea("FK1")
		FK1->(DbSetOrder(1))
		If(FK1->(DbSeek(xFilial('FK1')+cIdOrig)))
			DbSelectArea("FK6")
			FK6->(DbSetOrder(2))
			If(Fk6->(DbSeek(xFilial('FK6') + FK1->FK1_IDFK1 + "FK1")))
				While(FK6->(!EOF()) .And. FK6->FK6_FILIAL+FK6->FK6_IDORIG+FK6->FK6_TABORI == xFilial('FK6') + FK1->FK1_IDFK1 + cTabOri )

					If !lVerTipo .or. (FK6->FK6_TPDOC == cTipo)
						If(FK6->FK6_ACAO == '1' )
						
							nValCal += FK6->FK6_VALCAL
							nValMov += FK6->FK6_VALMOV
							
						Else
						
							nValCal -= FK6->FK6_VALCAL
							nValMov -= FK6->FK6_VALMOV
						
						EndIf
					Endif
					FK6->(DbSkip())
				End
			EndIf
		EndIf
	
	Else
		DbSelectArea("FK2")
		FK2->(DbSetOrder(1))
		If(FK2->(DbSeek(xFilial('FK2')+cIdOrig)))
			DbSelectArea("FK6")
			FK6->(DbSetOrder(2))
			If(FK6->(DbSeek(xFilial('FK6') + FK2->FK2_IDFK2 + "FK2")))
				While(FK6->(!EOF()) .And. FK6->FK6_FILIAL+FK6->FK6_IDORIG+FK6->FK6_TABORI == xFilial('FK6') + FK2->FK2_IDFK2 + cTabOri )
					If !lVerTipo .or. (FK6->FK6_TPDOC == cTipo)
						If(FK6->FK6_ACAO == '1' )
						
							nValCal += FK6->FK6_VALCAL
							nValMov += FK6->FK6_VALMOV
							
						Else
						
							nValCal -= FK6->FK6_VALCAL
							nValMov -= FK6->FK6_VALMOV
						
						EndIf
					Endif
					FK6->(DbSkip())
				End
			EndIf
		EndIf
	EndIf
		
	aAdd(aRet,{nValCal,nValMov})
Else
	aAdd(aRet,{0,0})
EndIf	

RestArea(aAreaFk2)
RestArea(aAreaFK6)
RestArea(aArea)

Return aRet

//--------------------------------------------------------------------------------------
/*/{Protheus.doc} FAtuFKDBx
Atualiza os valores de VA, informados na baixa, na tabela FKD
Acionada após a confirmação da baixa manual ou Lote.
 
@author pequim
@since 15/08/2016
@version undefined
@param lCancel
/*/
//--------------------------------------------------------------------------------------
Function FAtuFKDBx(lCancel)
Local aArea		 := GetArea()
Local oModelVA 	 := NIL
Local oSubFKD 	 := NIL
Local nX 		 := 0 
Local nTamFKD 	 := 0
Local dDtBaixa 	 := NIL
Local nRecSE1	 := SE1->(Recno())
Local cFilOriTit := ""
Local cChaveTit  := ""
Local cChaveFK7  := ""

DEFAULT lCancel := .F.

If TableInDic('FKD')
	cOldVA := Iif(Type("cOldVA") == 'U', "" , cOldVA)
	
	If lCancel
		dDTBaixa := SE1->E1_BAIXA
	Else
		dDTBaixa := Iif(Type("dBaixa") == "U", dDataBase , dBaixa)
	EndIf
	
	If !Empty(cOldVa)
	
		oModelVA := FWLoadModel("FINA070VA")
		oModelVA:SetOperation( MODEL_OPERATION_UPDATE )
		oModelVA:Activate()
		oModelVA:LoadXMLData( cOldVA )
		
		//Atualiza Data da baixa
		oSubFKD := oModelVA:GetModel("FKDDETAIL")
		nTamFKD := oSUBFKD:Length()
		
		For nX := 1 to nTamFKD
			oSubFKD:GoLine(nX)
			oSubFKD:LoadValue("FKD_DTBAIX", dDTBaixa)
		Next	
		
		If oModelVA:VldData()
			FWFormCommit( oModelVA )
		EndIf
		oModelVA:Deactivate()
		oModelVA:Destroy
		oModelVa := NIL
		cOldVA := ""
	Else
		cFilOriTit	:= xFilial("SE1",SE1->E1_FILORIG)					
		cChaveTit := cFilOriTit + '|' + SE1->E1_PREFIXO + '|' + SE1->E1_NUM + '|' + SE1->E1_PARCELA + '|' + SE1->E1_TIPO + '|' + SE1->E1_CLIENTE + '|' + SE1->E1_LOJA
		cChaveFK7 := FINGRVFK7("SE1", cChaveTit)
	
		DbSelectArea("FKD")
		FKD->(DbSetOrder(2))
		If FKD->(DbSeek(cFilOriTit+cChaveFK7))
			While FKD->(!Eof()) .And. FKD->FKD_FILIAL == cFilOriTit .And. FKD->FKD_IDDOC == cChaveFK7
				//Gravo o valor calculado e o valor informado para que gravações da FK6 
				RecLock("FKD")
				FKD->FKD_DTBAIX := dDTBaixa
				FKD->(MSUnlock())
							
				FKD->(DbSkip())
			EndDo
			SE1->(dbGoTo(nRecSE1))
		EndIf
	EndIf		
EndIf

RestArea(aArea)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} FormExpIn
Monta a expressão do IN/NOT IN da query 

@author Mauricio Pequim Jr
@version P12.1.8
@since	05/09/2016	
																				
/*/
//-------------------------------------------------------------------
Function FormExpIn(cTipos)

DEFAULT cTipos := MVPROVIS + "/" + MVRECANT + "/" + MV_CRNEG + "/" + MVABATIM
			
cTipos	:=	StrTran(cTipos,',','/')
cTipos	:=	StrTran(cTipos,';','/')
cTipos	:=	StrTran(cTipos,'|','/')
cTipos	:=	StrTran(cTipos,'\','/')

cTipos := Formatin(cTipos,"/")

Return cTipos

//-------------------------------------------------------------------
/*/{Protheus.doc} MovBcoPA()
Verifica se PA ja teve sua movimentacao bancaria

@author Igor Sousa do Nascimento
@since 16/10/2017
@version 1.0
/*/
//-------------------------------------------------------------------
Function MovBcoPA(cPrefixo,cNumero,cParcela,cTipo,cFornec,cLoja)
	Local aArea := {}
	Local cTmp  := ""
	Local lRet  := .F.
	Local cIn := ""
	
	Default cPrefixo := ""
	Default cNumero  := ""
	Default cParcela := ""
	Default cTipo 	 := ""
	Default cFornec  := ""
	Default cLoja 	 := ""
	
	If cTipo $ MVPAGANT
		aArea := GetArea()
		cTmp  := CriaTrab(,.F.)
		cIn := "%" + "SE5.E5_TIPODOC IN " + FormExpIn(MVPAGANT) + "%"
		
		BeginSQL Alias cTmp
			SELECT SE5.E5_TIPODOC 
			FROM %table:SE5% SE5
			WHERE
				SE5.E5_FILIAL 	   = %xfilial:SE5%
				AND SE5.E5_PREFIXO = %exp:cPrefixo%
				AND SE5.E5_NUMERO  = %exp:cNumero%
				AND SE5.E5_PARCELA = %exp:cParcela%
				AND SE5.E5_TIPO    = %exp:cTipo%
				AND SE5.E5_CLIFOR  = %exp:cFornec%
				AND SE5.E5_LOJA    = %exp:cLoja%
				AND %Exp:cIn%
				AND SE5.E5_SITUACA = ' '
				AND SE5.%NotDel%
		EndSQL
		
		If !(cTmp)->(EoF())
			lRet := .T.
		EndIf
		
		(cTmp)->(dbCloseArea())
		RestArea(aArea)
	Else
		lRet := .T.
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} GetPosts
Retorna array com recnos das baixas de um titulo
@param cChave - Chave unica do titulo
@param cFiltro - Filtro para baixas especificas
@author Igor Sousa do Nascimento
@since  05/01/2018
/*/
//-------------------------------------------------------------------
Function GetPosts(cXFilial,cPrefixo,cNum,cParcela,cTipo,cFornec,cLoja,cFiltro)

	Local aArea    := GetArea()
	Local aBaixas  := {}
	Local cTmp	   := CriaTrab(,.F.)
	Local cQuery   := ""

	Default cXFilial := ""
	Default cPrefixo := ""
	Default cNum 	 := ""
	Default cParcela := ""
	Default cTipo 	 := ""
	Default cFornec  := ""
	Default cLoja    := ""
	Default cFiltro  := ""

	If Empty(cXFilial) .and. Empty(cPrefixo) .and. Empty(cNum) .and.; 
		Empty(cParcela) .and. Empty(cTipo) .and. Empty(cFornec) .and. Empty(cLoja)
		If "SE2" $ Alias()
			cXFilial := xFilial("SE2")
			cPrefixo := E2_PREFIXO
			cNum 	 := E2_NUM
			cParcela := E2_PARCELA
			cTipo 	 := E2_TIPO
			cFornec  := E2_FORNECE
			cLoja 	 := E2_LOJA
		ElseIf "SE5" $ Alias()
			cXFilial := xFilial("SE5")
			cPrefixo := E5_PREFIXO
			cNum 	 := E5_NUMERO
			cParcela := E5_PARCELA
			cTipo 	 := E5_TIPO
			cFornec  := E5_CLIFOR
			cLoja 	 := E5_LOJA
		EndIf
	EndIf
	cQuery := "SELECT SE5.R_E_C_N_O_ RECNOBX "
	cQuery += "FROM " + RetSqlName("SE5") + " SE5 "
	cQuery += "WHERE "
	cQuery += "SE5.E5_FILIAL = '" + cXFilial + "' "
	cQuery += "AND SE5.E5_PREFIXO = '" + cPrefixo + "' "
	cQuery += "AND SE5.E5_NUMERO = '" + cNum + "' "
	cQuery += "AND SE5.E5_PARCELA = '" + cParcela + "' "
	cQuery += "AND SE5.E5_TIPO = '" + cTipo + "' "
	cQuery += "AND SE5.E5_CLIFOR = '" + cFornec + "' "
	cQuery += "AND SE5.E5_LOJA = '" + cLoja + "' "
	If !Empty(cFiltro)
		cQuery += "AND " + cFiltro
	EndIf
	cQuery += " AND SE5.E5_SITUACA NOT IN ( 'C' , 'E' , 'X' ) "
	cQuery += "AND SE5.E5_NUMERO NOT IN ( "
	cQuery += 			"SELECT SUBSE5.E5_NUMERO FROM " + RetSqlName("SE5") + " SUBSE5 "
	cQuery +=			"WHERE SUBSE5.E5_FILIAL = SE5.E5_FILIAL "
	cQuery += 			"AND SUBSE5.E5_PREFIXO = SE5.E5_PREFIXO "
	cQuery += 			"AND SUBSE5.E5_NUMERO = SE5.E5_NUMERO "
	cQuery += 			"AND SUBSE5.E5_PARCELA = SE5.E5_PARCELA "
	cQuery += 			"AND SUBSE5.E5_TIPO = SE5.E5_TIPO "
	cQuery += 			"AND SUBSE5.E5_CLIFOR = SE5.E5_CLIFOR "
	cQuery += 			"AND SUBSE5.E5_LOJA = SE5.E5_LOJA "
	cQuery += 			"AND SUBSE5.E5_TIPODOC = 'ES' "
	cQuery += 			"AND SUBSE5.E5_SEQ = SE5.E5_SEQ "
	cQuery += 			"AND SUBSE5.D_E_L_E_T_ = ' ' ) "
	cQuery += "AND SE5.D_E_L_E_T_ = ' '"
	cQuery := ChangeQuery(cQuery)
	MPSysOpenQuery(cQuery, cTmp)
	dbSelectArea(cTmp)
	While !(cTmp)->(EoF())
		Aadd(aBaixas, (cTmp)->RECNOBX)
		(cTmp)->(dbSkip())
	EndDo
	dbCloseArea(cTmp)
	RestArea(aArea)

Return aBaixas

//-------------------------------------------------------------------
/*/{Protheus.doc} TemBxCanc2
Recriado a fun‡?o TemBxCanc para melhor performance de busca

@author Karen Honda
@since 14/12/16
@version 1.0
/*/
//-------------------------------------------------------------------
Function TemBxCanc2()			
Local lRet := .F.	
Local aAreaSE5 := SE5->(GetArea())
Local cChave := SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ)

If SE5->(dbSeek(xFilial("SE5")+cChave))
	While SE5->(!Eof()) .and. xFilial("SE5")+cChave == SE5->(E5_FILIAL + E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO + E5_CLIFOR +E5_LOJA + E5_SEQ)
		If ( SE5->E5_TIPODOC == "ES" ) 
			lRet := .T.
			Exit
		EndIf
		SE5->(dbSkip())
	EndDo
EndIf

RestArea(aAreaSE5)

Return lRet

/*/{Protheus.doc}LimpResid
Ajusta o saldo do título, moeda estrangeira, quando
cancelamento total fica resíduo de 0.01 centavo
@author Sivaldo Oliveira
@since  16/03/2017
@version 12
/*/
Function LimpResid(cChave, nIndice, cCart, lCancel)
Local aArea := GetArea()
Local nVlrDif := 0

Default cChave := ""
Default nIndice := 0
Default cCart := "" 

If !Empty(cChave) .And. !Empty(nIndice) .And. !Empty(cCart)
	If cCart == "R"
		SE1->(DbSetOrder(nIndice))
		
		If SE1->(MsSeek(cChave))
			nVlrDif := Abs(If(lCancel, (SE1->E1_VALOR - SE1->E1_SALDO), SE1->E1_SALDO)) 
			
			If nVlrDif > 0 .And. nVlrDif <= 0.01 
				RecLock("SE1")
				If	lCancel 
					SE1->E1_SALDO := SE1->E1_VALOR
				ElseIf !lCancel
					SE1->E1_SALDO := 0
				EndIf 
				SE1->(MsUnlock())
			EndIf
		EndIf  
	Else
		SE2->(DbSetOrder(nIndice))
		
		If SE2->(MsSeek(cChave))
			nVlrDif := Abs(If(lCancel, (SE2->E2_VALOR - SE2->E2_SALDO), SE2->E2_SALDO)) 
			
			If nVlrDif > 0 .And. nVlrDif <= 0.01 
				RecLock("SE2")
				If	lCancel 
					SE2->E2_SALDO := SE2->E2_VALOR
				ElseIf !lCancel
					SE2->E2_SALDO := 0
				EndIf 
				SE2->(MsUnlock())
			EndIf
		EndIf 
	EndIf 
	RestArea(aArea)
EndIf

Return Nil
